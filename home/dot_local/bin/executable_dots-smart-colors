#!/usr/bin/env bash

## Copyright (C) 2019-2025 Ulises Jeremias Cornejo Fandos
## Licensed under MIT.
##
## Check full documentation at: https://github.com/ulises-jeremias/dotfiles/wiki
##
## Smart color palette analyzer and theme-adaptive color selector
## Analyzes your current X resources color palette and suggests the best colors
## for different semantic concepts (error, warning, success, info, etc.)
##
## Usage:
##     @script.name [OPTION] ARGUMENTS...
##
## Options:
##     -h, --help                            Show this help message.
##     -a, --analyze                         Analyze current palette and show recommendations.
##     -c, --colors                          Show visual color palette with blocks.
##     -e, --export                          Export color variables for shell/polybar.
##         --concept=CONCEPT                 Get best color for specific concept (error|warning|success|info|accent|red|green|blue|yellow|cyan|magenta|orange|pink|brown|white|black|gray).
##         --format=FORMAT                   Output format: hex, rgb, polybar, eww, scss, i3 (default: hex).
##         --cache                           Force regenerate color cache for faster lookups.
##     -v, --verbose                         Show detailed analysis.
##         --distance-algorithm=ALGO         Color distance algorithm: euclidean, cie76, simple (default: euclidean).

source ~/.local/lib/dots/easy-options/easyoptions.sh || exit

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Cache configuration
CACHE_DIR="${HOME}/.cache/wal"
CACHE_FILE="${CACHE_DIR}/smart-colors.cache"
CACHE_TIMESTAMP_FILE="${CACHE_DIR}/smart-colors.timestamp"

# Function to show status with colored output
show_status() {
    echo -e "${CYAN}🎨${NC} $1"
}

show_success() {
    echo -e "${GREEN}✅${NC} $1"
}

show_error() {
    echo -e "${RED}❌${NC} $1"
}

show_warning() {
    echo -e "${YELLOW}⚠️${NC} $1"
}

show_info() {
    echo -e "${BLUE}ℹ️${NC} $1"
}

# Check if cache is valid (newer than wal colors)
is_cache_valid() {
    local wal_colors_file="${CACHE_DIR}/colors"

    # Check if cache files exist
    [[ -f "$CACHE_FILE" && -f "$CACHE_TIMESTAMP_FILE" ]] || return 1

    # Check if wal colors exist
    [[ -f "$wal_colors_file" ]] || return 1

    # Compare timestamps
    local cache_time=$(stat -c %Y "$CACHE_TIMESTAMP_FILE" 2>/dev/null || echo "0")
    local wal_time=$(stat -c %Y "$wal_colors_file" 2>/dev/null || echo "0")

    [[ "$cache_time" -ge "$wal_time" ]]
}

# Read color from cache
read_from_cache() {
    local concept="$1"
    local format="${2:-hex}"

    if [[ ! -f "$CACHE_FILE" ]]; then
        return 1
    fi

    # Cache format: concept:format:color
    local cache_key="${concept}:${format}"
    local cached_color=$(grep "^${cache_key}:" "$CACHE_FILE" 2>/dev/null | cut -d: -f3)

    if [[ -n "$cached_color" ]]; then
        echo "$cached_color"
        return 0
    fi

    return 1
}

# Generate complete cache for all concepts and formats
generate_cache() {
    show_status "Generating smart colors cache..."

    # Ensure cache directory exists
    mkdir -p "$CACHE_DIR"

    # Temporarily disable cache to force fresh calculation
    local temp_cache="$CACHE_FILE.tmp"
    > "$temp_cache"

    # All concepts to cache
    local concepts=("error" "warning" "success" "info" "accent" "red" "green" "blue" "yellow" "cyan" "magenta" "orange" "pink" "brown" "white" "black" "gray")
    local formats=("hex" "rgb")

    local total_concepts=${#concepts[@]}
    local current=0

    for concept in "${concepts[@]}"; do
        ((current++))
        [[ -n "$verbose" ]] && show_status "Caching $concept ($current/$total_concepts)..."

        # Get the color using the normal calculation (bypass cache)
        CACHE_FILE="/dev/null"  # Temporarily disable cache reading

        for format in "${formats[@]}"; do
            # Calculate color with current format
            format="$format" verbose="" # Disable verbose for cache generation
            local color=$(find_best_color_for_concept "$concept" 2>/dev/null)

            if [[ -n "$color" ]]; then
                echo "${concept}:${format}:${color}" >> "$temp_cache"
            fi
        done

        # Restore cache file
        CACHE_FILE="${CACHE_DIR}/smart-colors.cache"
    done

    # Move temp cache to final location
    mv "$temp_cache" "$CACHE_FILE"

    # Update timestamp
    touch "$CACHE_TIMESTAMP_FILE"

    show_success "Smart colors cache generated (${#concepts[@]} concepts)"
}

# Force cache regeneration
regenerate_cache() {
    show_status "Forcing cache regeneration..."
    rm -f "$CACHE_FILE" "$CACHE_TIMESTAMP_FILE"
    generate_cache
}

# Convert hex color to RGB
hex_to_rgb() {
    local hex="$1"
    # Remove # if present
    hex="${hex#\#}"

    # Convert to RGB
    local r=$((16#${hex:0:2}))
    local g=$((16#${hex:2:2}))
    local b=$((16#${hex:4:2}))

    echo "$r $g $b"
}

# Convert hex color to ANSI escape code for background
hex_to_ansi_bg() {
    local hex="$1"
    local rgb=$(hex_to_rgb "$hex")
    local r g b
    read -r r g b <<< "$rgb"

    # Return ANSI 24-bit color escape code for background
    echo "\033[48;2;${r};${g};${b}m"
}

# Show color as a visual block in terminal
show_color_block() {
    local hex="$1"
    local label="$2"
    local width="${3:-8}"

    local ansi_bg=$(hex_to_ansi_bg "$hex")
    local reset="\033[0m"

    # Create color block with spaces
    local block=""
    for ((i=0; i<width; i++)); do
        block+=" "
    done

    # Print color block with label
    printf "${ansi_bg}${block}${reset} %-10s %s\n" "$label" "$hex"
}

# Show palette as visual color blocks
show_palette_visual() {
    echo -e "${BOLD}Visual Color Palette:${NC}"
    echo

    # Show all base16 colors in a nice layout
    echo "Base16 Colors:"
    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            show_color_block "$color" "color$i"
        fi
    done

    echo
    echo "Special Colors:"
    local bg=$(xrdb -get "background" 2>/dev/null)
    local fg=$(xrdb -get "foreground" 2>/dev/null)

    [[ -n "$bg" ]] && show_color_block "$bg" "background"
    [[ -n "$fg" ]] && show_color_block "$fg" "foreground"

    echo
    echo "Compact Palette View:"
    # Show all colors in a compact horizontal layout
    local color_line=""
    local reset="\033[0m"

    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            local ansi_bg=$(hex_to_ansi_bg "$color")
            color_line+="${ansi_bg}  ${reset}"
        fi
    done

    echo -e "$color_line"
    echo
}

# Convert hex color to HSL
hex_to_hsl() {
    local hex="$1"
    # Remove # if present
    hex="${hex#\#}"

    # Convert to RGB [0-255]
    local r=$((16#${hex:0:2}))
    local g=$((16#${hex:2:2}))
    local b=$((16#${hex:4:2}))

    # Convert RGB to [0-1] range for calculations
    local r_norm=$(echo "scale=6; $r / 255" | bc)
    local g_norm=$(echo "scale=6; $g / 255" | bc)
    local b_norm=$(echo "scale=6; $b / 255" | bc)

    # Find max and min values
    local max_val=$r_norm
    local min_val=$r_norm
    local max_component="r"

    if (( $(echo "$g_norm > $max_val" | bc -l) )); then
        max_val=$g_norm
        max_component="g"
    fi
    if (( $(echo "$b_norm > $max_val" | bc -l) )); then
        max_val=$b_norm
        max_component="b"
    fi

    if (( $(echo "$g_norm < $min_val" | bc -l) )); then
        min_val=$g_norm
    fi
    if (( $(echo "$b_norm < $min_val" | bc -l) )); then
        min_val=$b_norm
    fi

    # Calculate Lightness
    local lightness=$(echo "scale=6; ($max_val + $min_val) / 2" | bc)

    # Calculate Saturation and Hue
    local saturation=0
    local hue=0

    local delta=$(echo "scale=6; $max_val - $min_val" | bc)

    if (( $(echo "$delta != 0" | bc -l) )); then
        # Calculate Saturation
        if (( $(echo "$lightness <= 0.5" | bc -l) )); then
            saturation=$(echo "scale=6; $delta / ($max_val + $min_val)" | bc)
        else
            saturation=$(echo "scale=6; $delta / (2 - $max_val - $min_val)" | bc)
        fi

        # Calculate Hue
        case "$max_component" in
            "r")
                hue=$(echo "scale=6; (($g_norm - $b_norm) / $delta)" | bc)
                ;;
            "g")
                hue=$(echo "scale=6; 2 + (($b_norm - $r_norm) / $delta)" | bc)
                ;;
            "b")
                hue=$(echo "scale=6; 4 + (($r_norm - $g_norm) / $delta)" | bc)
                ;;
        esac

        hue=$(echo "scale=6; $hue * 60" | bc)

        # Normalize hue to [0-360]
        if (( $(echo "$hue < 0" | bc -l) )); then
            hue=$(echo "scale=6; $hue + 360" | bc)
        fi
    fi

    # Convert to output format: H [0-360], S [0-100], L [0-100]
    local h_out=$(echo "scale=2; $hue" | bc)
    local s_out=$(echo "scale=2; $saturation * 100" | bc)
    local l_out=$(echo "scale=2; $lightness * 100" | bc)

    echo "$h_out $s_out $l_out"
}

# Calculate angular distance between two hues (0-360 degrees)
hue_distance() {
    local h1=$1
    local h2=$2

    # Calculate absolute difference
    local diff=$(echo "scale=6; $h1 - $h2" | bc)
    if (( $(echo "$diff < 0" | bc -l) )); then
        diff=$(echo "scale=6; -1 * $diff" | bc)
    fi

    # Calculate circular distance (shortest path around the color wheel)
    local circular_diff=$(echo "scale=6; 360 - $diff" | bc)

    # Return the smaller distance
    if (( $(echo "$diff <= $circular_diff" | bc -l) )); then
        echo "$diff"
    else
        echo "$circular_diff"
    fi
}

# Calculate euclidean distance between two RGB colors (kept for compatibility)
color_distance_euclidean() {
    local r1=$1 g1=$2 b1=$3
    local r2=$4 g2=$5 b2=$6

    local dr=$((r1 - r2))
    local dg=$((g1 - g2))
    local db=$((b1 - b2))

    # Euclidean distance formula: sqrt((r1-r2)² + (g1-g2)² + (b1-b2)²)
    local distance_squared=$((dr*dr + dg*dg + db*db))
    echo "$distance_squared"
}

# Calculate color brightness (perceived luminance)
color_brightness() {
    local r=$1 g=$2 b=$3
    # Using ITU-R BT.709 formula for perceived brightness
    local brightness=$(echo "scale=2; 0.2126*$r + 0.7152*$g + 0.0722*$b" | bc)
    echo "$brightness"
}

# Get color temperature (warm vs cool)
color_temperature() {
    local r=$1 g=$2 b=$3
    # Simple temperature calculation: red-heavy = warm, blue-heavy = cool
    local temp_score=$(echo "scale=2; ($r - $b) / 255" | bc)
    echo "$temp_score"
}

# Get all available colors from xrdb
get_xrdb_colors() {
    declare -A colors

    # Get standard colors 0-15
    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            colors["color$i"]="$color"
        fi
    done

    # Get special colors
    local bg=$(xrdb -get "background" 2>/dev/null)
    local fg=$(xrdb -get "foreground" 2>/dev/null)

    [[ -n "$bg" ]] && colors["background"]="$bg"
    [[ -n "$fg" ]] && colors["foreground"]="$fg"

    # Return as key=value pairs
    for key in "${!colors[@]}"; do
        echo "$key=${colors[$key]}"
    done
}

# Define reference colors for each concept (ideal base colors)
get_reference_color() {
    local concept="$1"

    case "$concept" in
        "error"|"danger"|"red")
            echo "#ff0000"  # Pure red
            ;;
        "warning"|"caution"|"orange")
            echo "#ff9900"  # Orange
            ;;
        "yellow")
            echo "#ffff00"  # Pure yellow
            ;;
        "success"|"ok"|"green")
            echo "#00ff00"  # Pure green
            ;;
        "info"|"neutral"|"blue")
            echo "#0066ff"  # Bright blue
            ;;
        "cyan")
            echo "#00ffff"  # Pure cyan
            ;;
        "magenta"|"purple")
            echo "#ff00ff"  # Pure magenta
            ;;
        "pink")
            echo "#ff77aa"  # Pink
            ;;
        "accent"|"highlight")
            echo "#8800ff"  # Purple/Violet
            ;;
        "brown")
            echo "#8b4513"  # Saddle brown
            ;;
        "white")
            echo "#ffffff"  # Pure white
            ;;
        "black")
            echo "#000000"  # Pure black
            ;;
        "gray"|"grey")
            echo "#808080"  # Gray
            ;;
        *)
            echo "#ff0000"  # Default to red
            ;;
    esac
}

# Calculate palette characteristics for adaptation
analyze_palette_characteristics() {
    local total_sat=0
    local total_light=0
    local color_count=0

    # Analyze colors 1-14 (skip 0=black, 15=white usually)
    for i in {1..14}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            local hsl=$(hex_to_hsl "$color")
            local h s l
            read -r h s l <<< "$hsl"

            total_sat=$(echo "scale=6; $total_sat + $s" | bc)
            total_light=$(echo "scale=6; $total_light + $l" | bc)
            ((color_count++))
        fi
    done

    if [[ $color_count -gt 0 ]]; then
        local avg_sat=$(echo "scale=2; $total_sat / $color_count" | bc)
        local avg_light=$(echo "scale=2; $total_light / $color_count" | bc)
        echo "$avg_sat $avg_light"
    else
        echo "70 50"  # Default values
    fi
}

# Adapt reference color to palette aesthetics
adapt_color_to_palette() {
    local reference_hex="$1"
    local palette_characteristics="$2"
    local adaptation_strength="$3"  # 0.0 to 1.0

    local palette_avg_sat palette_avg_light
    read -r palette_avg_sat palette_avg_light <<< "$palette_characteristics"

    # Get reference color HSL
    local ref_hsl=$(hex_to_hsl "$reference_hex")
    local ref_h ref_s ref_l
    read -r ref_h ref_s ref_l <<< "$ref_hsl"

    # Adapt saturation and lightness towards palette average
    local adapted_s=$(echo "scale=2; $ref_s + ($palette_avg_sat - $ref_s) * $adaptation_strength" | bc)
    local adapted_l=$(echo "scale=2; $ref_l + ($palette_avg_light - $ref_l) * $adaptation_strength" | bc)

    # Ensure values stay within bounds
    if (( $(echo "$adapted_s < 0" | bc -l) )); then adapted_s=0; fi
    if (( $(echo "$adapted_s > 100" | bc -l) )); then adapted_s=100; fi
    if (( $(echo "$adapted_l < 10" | bc -l) )); then adapted_l=10; fi
    if (( $(echo "$adapted_l > 90" | bc -l) )); then adapted_l=90; fi

    # Convert back to hex
    hsl_to_hex "$ref_h" "$adapted_s" "$adapted_l"
}

# Convert HSL back to hex (robust simplified version)
hsl_to_hex() {
    local h="$1" s="$2" l="$3"

    # Clamp values to safe ranges
    h=$(echo "scale=0; if ($h < 0) 0 else if ($h >= 360) ($h - 360) else $h" | bc)
    s=$(echo "scale=0; if ($s < 0) 0 else if ($s > 100) 100 else $s" | bc)
    l=$(echo "scale=0; if ($l < 0) 0 else if ($l > 100) 100 else $l" | bc)

    # Simple approximation: adjust base color by saturation and lightness
    local r=255 g=0 b=0  # Start with red

    # Determine base color by hue (simplified sectors)
    if (( $(echo "$h >= 0 && $h < 60" | bc -l) )); then
        # Red to Yellow
        r=255
        g=$(echo "scale=0; 255 * $h / 60" | bc)
        b=0
    elif (( $(echo "$h >= 60 && $h < 120" | bc -l) )); then
        # Yellow to Green
        r=$(echo "scale=0; 255 * (120 - $h) / 60" | bc)
        g=255
        b=0
    elif (( $(echo "$h >= 120 && $h < 180" | bc -l) )); then
        # Green to Cyan
        r=0
        g=255
        b=$(echo "scale=0; 255 * ($h - 120) / 60" | bc)
    elif (( $(echo "$h >= 180 && $h < 240" | bc -l) )); then
        # Cyan to Blue
        r=0
        g=$(echo "scale=0; 255 * (240 - $h) / 60" | bc)
        b=255
    elif (( $(echo "$h >= 240 && $h < 300" | bc -l) )); then
        # Blue to Magenta
        r=$(echo "scale=0; 255 * ($h - 240) / 60" | bc)
        g=0
        b=255
    else
        # Magenta to Red
        r=255
        g=0
        b=$(echo "scale=0; 255 * (360 - $h) / 60" | bc)
    fi

    # Apply saturation (mix with gray)
    local gray=$(echo "scale=0; $l * 255 / 100" | bc)
    local sat_factor=$(echo "scale=6; $s / 100" | bc)

    r=$(echo "scale=0; $r * $sat_factor + $gray * (1 - $sat_factor)" | bc)
    g=$(echo "scale=0; $g * $sat_factor + $gray * (1 - $sat_factor)" | bc)
    b=$(echo "scale=0; $b * $sat_factor + $gray * (1 - $sat_factor)" | bc)

    # Apply lightness adjustment
    local light_factor=$(echo "scale=6; $l / 50" | bc)  # 50 is middle lightness
    if (( $(echo "$l > 50" | bc -l) )); then
        # Lighten by mixing with white
        local white_mix=$(echo "scale=6; ($l - 50) / 50" | bc)
        r=$(echo "scale=0; $r + (255 - $r) * $white_mix" | bc)
        g=$(echo "scale=0; $g + (255 - $g) * $white_mix" | bc)
        b=$(echo "scale=0; $b + (255 - $b) * $white_mix" | bc)
    elif (( $(echo "$l < 50" | bc -l) )); then
        # Darken by reducing values
        local dark_factor=$(echo "scale=6; $l / 50" | bc)
        r=$(echo "scale=0; $r * $dark_factor" | bc)
        g=$(echo "scale=0; $g * $dark_factor" | bc)
        b=$(echo "scale=0; $b * $dark_factor" | bc)
    fi

    # Ensure integer values and clamp to 0-255
    r=$(echo "$r" | cut -d. -f1)
    g=$(echo "$g" | cut -d. -f1)
    b=$(echo "$b" | cut -d. -f1)

    # Final bounds check
    if [[ "$r" -lt 0 ]]; then r=0; elif [[ "$r" -gt 255 ]]; then r=255; fi
    if [[ "$g" -lt 0 ]]; then g=0; elif [[ "$g" -gt 255 ]]; then g=255; fi
    if [[ "$b" -lt 0 ]]; then b=0; elif [[ "$b" -gt 255 ]]; then b=255; fi

    printf "#%02x%02x%02x" "$r" "$g" "$b"
}

# Fast lookup table for color adaptation (avoids heavy HSL calculations)
get_fast_adapted_color() {
    local concept="$1"
    local palette_has_color="$2"  # "red", "blue", etc. from simple hue check

        # Quick adaptation table based on palette dominant color
    case "$concept|$palette_has_color" in
        # ERROR/RED concept
        "error|red"|"red|red") echo "#ff0000" ;;
        "error|orange"|"red|orange") echo "#ff3300" ;;
        "error|pink"|"red|pink") echo "#ff6666" ;;
        "error|purple"|"red|purple") echo "#ff4488" ;;
        "error|*") echo "#cc4444" ;;

        # WARNING/ORANGE concept
        "warning|orange"|"orange|orange") echo "#ff9900" ;;
        "warning|yellow"|"orange|yellow") echo "#ffcc00" ;;
        "warning|red"|"orange|red") echo "#ff6600" ;;
        "warning|pink"|"orange|pink") echo "#ff8844" ;;
        "warning|*") echo "#cc8800" ;;

        # SUCCESS/GREEN concept
        "success|green"|"green|green") echo "#00ff00" ;;
        "success|cyan"|"green|cyan") echo "#00cc66" ;;
        "success|blue"|"green|blue") echo "#0099aa" ;;
        "success|orange"|"green|orange") echo "#88cc44" ;;
        "success|*") echo "#669944" ;;

        # INFO/BLUE concept
        "info|blue"|"blue|blue") echo "#0066ff" ;;
        "info|cyan"|"blue|cyan") echo "#0099cc" ;;
        "info|purple"|"blue|purple") echo "#6666cc" ;;
        "info|orange"|"blue|orange") echo "#4488cc" ;;
        "info|*") echo "#4488cc" ;;

        # ACCENT concept
        "accent|purple"|"highlight|purple") echo "#aa66ff" ;;
        "accent|pink"|"highlight|pink") echo "#ff66aa" ;;
        "accent|orange"|"highlight|orange") echo "#ff8833" ;;
        "accent|*") echo "#8866aa" ;;

        # BASIC COLORS
        "yellow|yellow") echo "#ffff00" ;;
        "yellow|orange") echo "#ffcc00" ;;
        "yellow|red") echo "#ffaa00" ;;
        "yellow|*") echo "#cccc44" ;;

        "cyan|cyan") echo "#00ffff" ;;
        "cyan|blue") echo "#0099cc" ;;
        "cyan|green") echo "#00ccaa" ;;
        "cyan|*") echo "#4499aa" ;;

        "magenta|purple"|"purple|purple") echo "#ff00ff" ;;
        "magenta|pink"|"purple|pink") echo "#ff66cc" ;;
        "magenta|orange"|"purple|orange") echo "#ff6699" ;;
        "magenta|*") echo "#cc66aa" ;;

        "pink|pink") echo "#ff88cc" ;;
        "pink|purple") echo "#ff66aa" ;;
        "pink|orange") echo "#ffaa88" ;;
        "pink|red") echo "#ff8899" ;;
        "pink|*") echo "#dd99bb" ;;

        "brown|red") echo "#aa4422" ;;
        "brown|orange") echo "#cc6633" ;;
        "brown|*") echo "#996633" ;;

        *) echo "#888888" ;;  # Fallback gray
    esac
}

# Calculate fast palette average (RGB only, no HSL)
get_palette_average() {
    local total_r=0 total_g=0 total_b=0
    local color_count=0

    # Sample key colors from palette
    for i in {1..14}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            local hex="${color#\#}"
            local r=$((16#${hex:0:2}))
            local g=$((16#${hex:2:2}))
            local b=$((16#${hex:4:2}))

            total_r=$((total_r + r))
            total_g=$((total_g + g))
            total_b=$((total_b + b))
            ((color_count++))
        fi
    done

    if [[ $color_count -gt 0 ]]; then
        local avg_r=$((total_r / color_count))
        local avg_g=$((total_g / color_count))
        local avg_b=$((total_b / color_count))
        printf "#%02x%02x%02x" "$avg_r" "$avg_g" "$avg_b"
    else
        echo "#808080"  # Fallback gray
    fi
}

# Fast color blending (no float arithmetic)
blend_colors() {
    local color1="$1"    # Base color (from lookup)
    local color2="$2"    # Palette average
    local blend_percent="$3"  # 0-100, how much of color2 to mix in

    # Extract RGB from both colors
    local hex1="${color1#\#}"
    local r1=$((16#${hex1:0:2}))
    local g1=$((16#${hex1:2:2}))
    local b1=$((16#${hex1:4:2}))

    local hex2="${color2#\#}"
    local r2=$((16#${hex2:0:2}))
    local g2=$((16#${hex2:2:2}))
    local b2=$((16#${hex2:4:2}))

    # Simple linear interpolation
    local inv_percent=$((100 - blend_percent))
    local result_r=$(((r1 * inv_percent + r2 * blend_percent) / 100))
    local result_g=$(((g1 * inv_percent + g2 * blend_percent) / 100))
    local result_b=$(((b1 * inv_percent + b2 * blend_percent) / 100))

    # Clamp to 0-255 range
    if [[ $result_r -gt 255 ]]; then result_r=255; elif [[ $result_r -lt 0 ]]; then result_r=0; fi
    if [[ $result_g -gt 255 ]]; then result_g=255; elif [[ $result_g -lt 0 ]]; then result_g=0; fi
    if [[ $result_b -gt 255 ]]; then result_b=255; elif [[ $result_b -lt 0 ]]; then result_b=0; fi

    printf "#%02x%02x%02x" "$result_r" "$result_g" "$result_b"
}

# Fast dominant color detection (no HSL conversion needed)
get_palette_dominant_color() {
    local brightest_color=""
    local brightest_value=0

    # Check bright colors (9-14) for dominant hue
    for i in {9..14}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            # Quick RGB extraction
            local hex="${color#\#}"
            local r=$((16#${hex:0:2}))
            local g=$((16#${hex:2:2}))
            local b=$((16#${hex:4:2}))

            # Simple brightness
            local brightness=$((r + g + b))
            if [[ $brightness -gt $brightest_value ]]; then
                brightest_value=$brightness
                brightest_color="$color"
            fi
        fi
    done

    # Quick hue classification without HSL conversion
    if [[ -n "$brightest_color" ]]; then
        local hex="${brightest_color#\#}"
        local r=$((16#${hex:0:2}))
        local g=$((16#${hex:2:2}))
        local b=$((16#${hex:4:2}))

        # Simple hue detection based on RGB dominance
        if [[ $r -gt $g && $r -gt $b ]]; then
            if [[ $g -gt 100 ]]; then
                echo "orange"
            elif [[ $b -gt 100 ]]; then
                echo "purple"
            else
                echo "red"
            fi
        elif [[ $g -gt $r && $g -gt $b ]]; then
            if [[ $r -gt 100 ]]; then
                echo "yellow"
            elif [[ $b -gt 100 ]]; then
                echo "cyan"
            else
                echo "green"
            fi
        elif [[ $b -gt $r && $b -gt $g ]]; then
            if [[ $r -gt 100 ]]; then
                echo "purple"
            elif [[ $g -gt 100 ]]; then
                echo "cyan"
            else
                echo "blue"
            fi
        else
            echo "gray"
        fi
    else
        echo "unknown"
    fi
}

# Find best color for a specific concept (FAST VERSION with CACHE)
find_best_color_for_concept() {
    local concept="$1"

    # Validate concept
    case "$concept" in
        "error"|"danger"|"red"|"warning"|"caution"|"orange"|"yellow"|"success"|"ok"|"green"|"info"|"neutral"|"blue"|"cyan"|"magenta"|"purple"|"pink"|"accent"|"highlight"|"brown"|"white"|"black"|"gray"|"grey") ;;
        *)
            show_error "Unknown concept: $concept"
            echo "Available concepts:"
            echo "  Semantic: error, warning, success, info, accent"
            echo "  Colors: red, green, blue, yellow, cyan, magenta, orange, pink, brown, white, black, gray"
            return 1
            ;;
    esac

    # Try cache first (skip if we're currently generating cache)
    if [[ "$CACHE_FILE" != "/dev/null" ]] && is_cache_valid; then
        local cached_color=$(read_from_cache "$concept" "${format:-hex}")
        if [[ -n "$cached_color" ]]; then
            echo "$cached_color"
            [[ -n "$verbose" ]] && show_info "Using cached color for $concept: $cached_color"
            return 0
        fi
    fi

    # For black/white/gray, use palette directly
    case "$concept" in
        "black")
            local bg=$(xrdb -get "background" 2>/dev/null || echo "#000000")
            echo "$bg"
            [[ -n "$verbose" ]] && show_info "Using background color for black: $bg"
            return 0
            ;;
        "white")
            local fg=$(xrdb -get "foreground" 2>/dev/null || echo "#ffffff")
            echo "$fg"
            [[ -n "$verbose" ]] && show_info "Using foreground color for white: $fg"
            return 0
            ;;
        "gray"|"grey")
            local gray=$(xrdb -get "color8" 2>/dev/null || echo "#808080")
            echo "$gray"
            [[ -n "$verbose" ]] && show_info "Using color8 for gray: $gray"
            return 0
            ;;
    esac

        # Fast palette analysis
    local dominant_color=$(get_palette_dominant_color)
    local palette_average=$(get_palette_average)

    # Get base color from lookup table
    local base_color=$(get_fast_adapted_color "$concept" "$dominant_color")

    # Harmonize with palette average (15% blend for subtle adaptation)
    local blend_strength=15
    local final_color=$(blend_colors "$base_color" "$palette_average" "$blend_strength")

    local best_color="$final_color"
    local best_source="palette-harmonized"

    [[ -n "$verbose" ]] && show_info "Fast adaptation: $concept (dominant: $dominant_color, avg: $palette_average) → $base_color → $best_color"

    case "${format:-hex}" in
        "hex")
            echo "$best_color"
            ;;
        "rgb")
            hex_to_rgb "$best_color"
            ;;
        "polybar")
            # For polybar, we can't use xrdb reference since it's adapted
            echo "$best_color"
            ;;
        *)
            echo "$best_color"
            ;;
    esac

    [[ -n "$verbose" ]] && show_info "Best $concept color: $best_color (from $best_source)"
}

# Analyze complete palette
analyze_palette() {
    show_status "Analyzing current color palette..."
    echo

    # Show visual palette first
    show_palette_visual

    # Show current palette (text format)
    echo -e "${BOLD}Current Palette (Text):${NC}"
    while IFS= read -r line; do
        local key="${line%=*}"
        local color="${line#*=}"
        echo "  $key: $color"
    done < <(get_xrdb_colors)

    echo
    echo -e "${BOLD}Semantic Color Recommendations:${NC}"

    # Get recommendations for each concept
    local semantic_concepts=("error" "warning" "success" "info" "accent")
    for concept in "${semantic_concepts[@]}"; do
        local recommended_color=$(find_best_color_for_concept "$concept")
        show_color_block "$recommended_color" "$concept" 6
    done

    echo
    echo -e "${BOLD}Basic Color Recommendations:${NC}"

    # Get recommendations for basic colors
    local basic_colors=("red" "green" "blue" "yellow" "cyan" "magenta" "orange" "pink")
    for color in "${basic_colors[@]}"; do
        local recommended_color=$(find_best_color_for_concept "$color")
        show_color_block "$recommended_color" "$color" 6
    done

    echo
    echo -e "${BOLD}Palette Analysis:${NC}"

    # Analyze palette characteristics
    local warm_colors=0
    local cool_colors=0
    local bright_colors=0
    local dark_colors=0

    while IFS= read -r line; do
        local color="${line#*=}"
        [[ "$color" =~ ^#[0-9a-fA-F]{6}$ ]] || continue

        local rgb=$(hex_to_rgb "$color")
        local r g b
        read -r r g b <<< "$rgb"

        local brightness=$(color_brightness "$r" "$g" "$b")
        local temperature=$(color_temperature "$r" "$g" "$b")

        if (( $(echo "$temperature > 0" | bc -l) )); then
            ((warm_colors++))
        else
            ((cool_colors++))
        fi

        if (( $(echo "$brightness > 128" | bc -l) )); then
            ((bright_colors++))
        else
            ((dark_colors++))
        fi
    done < <(get_xrdb_colors)

    echo "  Warm colors: $warm_colors | Cool colors: $cool_colors"
    echo "  Bright colors: $bright_colors | Dark colors: $dark_colors"

    # Theme type suggestion
    if [[ "$warm_colors" -gt "$cool_colors" ]]; then
        echo "  Theme tendency: Warm palette 🔥"
    else
        echo "  Theme tendency: Cool palette ❄️"
    fi
}

# Export color variables
export_colors() {
    show_status "Exporting smart color variables..."

    echo "# Smart color variables generated by dots-smart-colors"
    echo "# Source this file or copy to your shell/polybar config"
    echo

    echo "# Semantic colors"
    local semantic_concepts=("error" "warning" "success" "info" "accent")
    for concept in "${semantic_concepts[@]}"; do
        local color=$(find_best_color_for_concept "$concept")
        echo "export SMART_COLOR_${concept^^}='$color'"
    done

    echo
    echo "# Basic colors"
    local basic_colors=("red" "green" "blue" "yellow" "cyan" "magenta" "orange" "pink" "brown" "white" "black" "gray")
    for color in "${basic_colors[@]}"; do
        local color_value=$(find_best_color_for_concept "$color")
        echo "export SMART_COLOR_${color^^}='$color_value'"
    done

    echo
    echo "# Polybar format variables (semantic)"
    for concept in "${semantic_concepts[@]}"; do
        local color=$(format="polybar" find_best_color_for_concept "$concept")
        echo "# smart-$concept = $color"
    done

    echo
    echo "# Polybar format variables (basic colors)"
    for color in "${basic_colors[@]}"; do
        local color_value=$(format="polybar" find_best_color_for_concept "$color")
        echo "# smart-$color = $color_value"
    done
}

# Export EWW SCSS color variables
export_eww_scss() {
    show_status "Generating EWW SCSS color variables..."

    echo "/* EWW SCSS color variables generated by dots-smart-colors */"
    echo "/* Auto-generated - do not edit manually */"
    echo

    # Export base colors from xrdb
    echo "/* Base colors from X resources */"
    local bg=$(xrdb -get "background" 2>/dev/null || echo "#000000")
    local fg=$(xrdb -get "foreground" 2>/dev/null || echo "#ffffff")

    echo "\$background: $bg;"
    echo "\$foreground: $fg;"
    echo

    # Export all base16 colors
    echo "/* Base16 color palette */"
    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null || echo "#000000")
        echo "\$color$i: $color;"
    done

    echo
    echo "/* Smart semantic colors (theme-adaptive) */"
    local semantic_concepts=("error" "warning" "success" "info" "accent")
    for concept in "${semantic_concepts[@]}"; do
        local color=$(find_best_color_for_concept "$concept")
        echo "\$smart-$concept: $color;"
    done

    echo
    echo "/* Smart basic colors (theme-adaptive) */"
    local basic_colors=("red" "green" "blue" "yellow" "cyan" "magenta" "orange" "pink")
    for color in "${basic_colors[@]}"; do
        local color_value=$(find_best_color_for_concept "$color")
        echo "\$smart-$color: $color_value;"
    done

    echo
    echo "/* Compatibility aliases for existing EWW configs */"
    echo "\$wallpaper: url('\$HOME/.cache/wal/wallpaper');"
}

# Export i3 color variables
export_i3_colors() {
    show_status "Generating i3 color variables..."

    echo "# i3 color variables generated by dots-smart-colors"
    echo "# Auto-generated - do not edit manually"
    echo

    echo "# Base colors from X resources"
    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null || echo "#000000")
        printf "set \$base%02X %s\n" "$i" "$color"
    done

    echo
    echo "# Smart semantic colors (theme-adaptive)"
    local concepts=("error" "warning" "success" "info" "accent")
    for concept in "${concepts[@]}"; do
        local color=$(find_best_color_for_concept "$concept")
        echo "set \$smart_$concept $color"
    done

    echo
    echo "# Smart basic colors (theme-adaptive)"
    local colors=("red" "green" "blue" "yellow" "cyan" "magenta")
    for color in "${colors[@]}"; do
        local color_value=$(find_best_color_for_concept "$color")
        echo "set \$smart_$color $color_value"
    done

    echo
    echo "# Recommended i3 color scheme using smart colors"
    echo "# client.focused          \$smart_accent  \$smart_accent  \$background     \$smart_info    \$smart_accent"
    echo "# client.focused_inactive \$background    \$background    \$foreground     \$background    \$background"
    echo "# client.unfocused        \$background    \$background    \$foreground     \$background    \$background"
    echo "# client.urgent           \$smart_error   \$smart_error   \$background     \$smart_error   \$smart_error"
}

# Main script logic
main() {
    # Check dependencies
    if ! command -v xrdb >/dev/null 2>&1; then
        show_error "xrdb command not found. Please install X11 utilities."
        exit 1
    fi

    if ! command -v bc >/dev/null 2>&1; then
        show_error "bc command not found. Please install bc for calculations."
        exit 1
    fi

    # Handle options
    if [[ -n "$cache" ]]; then
        regenerate_cache
    elif [[ -n "$analyze" ]]; then
        analyze_palette
    elif [[ -n "$colors" ]]; then
        show_palette_visual
    elif [[ -n "$export" ]]; then
        case "${format:-shell}" in
            "eww"|"scss")
                export_eww_scss
                ;;
            "i3")
                export_i3_colors
                ;;
            *)
                export_colors
                ;;
        esac
    elif [[ -n "$concept" ]]; then
        find_best_color_for_concept "$concept"
    else
        # Auto-generate cache if it doesn't exist or is invalid
        if ! is_cache_valid; then
            [[ -n "$verbose" ]] && show_status "Cache is invalid or missing, generating..."
            generate_cache
        fi

        # Default: show quick analysis with visual colors
        show_status "Quick palette analysis (use --analyze for detailed view)"
        echo

        echo -e "${BOLD}Semantic Colors:${NC}"
        local semantic_concepts=("error" "warning" "success" "info" "accent")
        for concept in "${semantic_concepts[@]}"; do
            local color=$(find_best_color_for_concept "$concept")
            show_color_block "$color" "$concept" 6
        done

        echo
        echo -e "${BOLD}Basic Colors:${NC}"
        local basic_colors=("red" "green" "blue" "yellow" "cyan" "magenta")
        for color in "${basic_colors[@]}"; do
            local color_value=$(find_best_color_for_concept "$color")
            show_color_block "$color_value" "$color" 6
        done

        echo
        echo -e "${BOLD}Compact Palette:${NC}"
        # Show current palette in compact view
        local color_line=""
        local reset="\033[0m"

        for i in {0..15}; do
            local palette_color=$(xrdb -get "color$i" 2>/dev/null)
            if [[ -n "$palette_color" ]]; then
                local ansi_bg=$(hex_to_ansi_bg "$palette_color")
                color_line+="${ansi_bg}  ${reset}"
            fi
        done

        echo -e "$color_line"

        echo
        show_info "Use 'dots-smart-colors --help' for more options"
        show_info "Use 'dots-smart-colors --colors' to see full visual palette"
        show_info "Available concepts: error, warning, success, info, accent, red, green, blue, yellow, cyan, magenta, orange, pink, brown, white, black, gray"
    fi
}

# Run main function
main "$@"
