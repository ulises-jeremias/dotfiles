#!/usr/bin/env bash

## Copyright (C) 2019-2025 Ulises Jeremias Cornejo Fandos
## Licensed under MIT.
##
## Check full documentation at: https://github.com/ulises-jeremias/dotfiles/wiki
##
## Smart color palette analyzer and theme-adaptive color selector
## Analyzes your current X resources color palette and suggests the best colors
## for different semantic concepts (error, warning, success, info, etc.)
##
## Usage:
##     @script.name [OPTION] ARGUMENTS...
##
## Options:
##     -h, --help                            Show this help message.
##     -a, --analyze                         Analyze current palette and show recommendations.
##     -c, --colors                          Show visual color palette with blocks.
##     -e, --export                          Export color variables for shell/polybar.
##         --concept=CONCEPT                 Get best color for specific concept (error|warning|success|info|accent|red|green|blue|yellow|cyan|magenta|orange|pink|brown|white|black|gray).
##         --format=FORMAT                   Output format: hex, rgb, polybar, eww, scss, i3 (default: hex).
##     -v, --verbose                         Show detailed analysis.
##         --distance-algorithm=ALGO         Color distance algorithm: euclidean, cie76, simple (default: euclidean).

source ~/.local/lib/dots/easy-options/easyoptions.sh || exit

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Function to show status with colored output
show_status() {
    echo -e "${CYAN}üé®${NC} $1"
}

show_success() {
    echo -e "${GREEN}‚úÖ${NC} $1"
}

show_error() {
    echo -e "${RED}‚ùå${NC} $1"
}

show_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è${NC} $1"
}

show_info() {
    echo -e "${BLUE}‚ÑπÔ∏è${NC} $1"
}

# Convert hex color to RGB
hex_to_rgb() {
    local hex="$1"
    # Remove # if present
    hex="${hex#\#}"

    # Convert to RGB
    local r=$((16#${hex:0:2}))
    local g=$((16#${hex:2:2}))
    local b=$((16#${hex:4:2}))

    echo "$r $g $b"
}

# Convert hex color to ANSI escape code for background
hex_to_ansi_bg() {
    local hex="$1"
    local rgb=$(hex_to_rgb "$hex")
    local r g b
    read -r r g b <<< "$rgb"

    # Return ANSI 24-bit color escape code for background
    echo "\033[48;2;${r};${g};${b}m"
}

# Show color as a visual block in terminal
show_color_block() {
    local hex="$1"
    local label="$2"
    local width="${3:-8}"

    local ansi_bg=$(hex_to_ansi_bg "$hex")
    local reset="\033[0m"

    # Create color block with spaces
    local block=""
    for ((i=0; i<width; i++)); do
        block+=" "
    done

    # Print color block with label
    printf "${ansi_bg}${block}${reset} %-10s %s\n" "$label" "$hex"
}

# Show palette as visual color blocks
show_palette_visual() {
    echo -e "${BOLD}Visual Color Palette:${NC}"
    echo

    # Show all base16 colors in a nice layout
    echo "Base16 Colors:"
    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            show_color_block "$color" "color$i"
        fi
    done

    echo
    echo "Special Colors:"
    local bg=$(xrdb -get "background" 2>/dev/null)
    local fg=$(xrdb -get "foreground" 2>/dev/null)

    [[ -n "$bg" ]] && show_color_block "$bg" "background"
    [[ -n "$fg" ]] && show_color_block "$fg" "foreground"

    echo
    echo "Compact Palette View:"
    # Show all colors in a compact horizontal layout
    local color_line=""
    local reset="\033[0m"

    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            local ansi_bg=$(hex_to_ansi_bg "$color")
            color_line+="${ansi_bg}  ${reset}"
        fi
    done

    echo -e "$color_line"
    echo
}

# Convert hex color to HSL
hex_to_hsl() {
    local hex="$1"
    # Remove # if present
    hex="${hex#\#}"

    # Convert to RGB [0-255]
    local r=$((16#${hex:0:2}))
    local g=$((16#${hex:2:2}))
    local b=$((16#${hex:4:2}))

    # Convert RGB to [0-1] range for calculations
    local r_norm=$(echo "scale=6; $r / 255" | bc)
    local g_norm=$(echo "scale=6; $g / 255" | bc)
    local b_norm=$(echo "scale=6; $b / 255" | bc)

    # Find max and min values
    local max_val=$r_norm
    local min_val=$r_norm
    local max_component="r"

    if (( $(echo "$g_norm > $max_val" | bc -l) )); then
        max_val=$g_norm
        max_component="g"
    fi
    if (( $(echo "$b_norm > $max_val" | bc -l) )); then
        max_val=$b_norm
        max_component="b"
    fi

    if (( $(echo "$g_norm < $min_val" | bc -l) )); then
        min_val=$g_norm
    fi
    if (( $(echo "$b_norm < $min_val" | bc -l) )); then
        min_val=$b_norm
    fi

    # Calculate Lightness
    local lightness=$(echo "scale=6; ($max_val + $min_val) / 2" | bc)

    # Calculate Saturation and Hue
    local saturation=0
    local hue=0

    local delta=$(echo "scale=6; $max_val - $min_val" | bc)

    if (( $(echo "$delta != 0" | bc -l) )); then
        # Calculate Saturation
        if (( $(echo "$lightness <= 0.5" | bc -l) )); then
            saturation=$(echo "scale=6; $delta / ($max_val + $min_val)" | bc)
        else
            saturation=$(echo "scale=6; $delta / (2 - $max_val - $min_val)" | bc)
        fi

        # Calculate Hue
        case "$max_component" in
            "r")
                hue=$(echo "scale=6; (($g_norm - $b_norm) / $delta)" | bc)
                ;;
            "g")
                hue=$(echo "scale=6; 2 + (($b_norm - $r_norm) / $delta)" | bc)
                ;;
            "b")
                hue=$(echo "scale=6; 4 + (($r_norm - $g_norm) / $delta)" | bc)
                ;;
        esac

        hue=$(echo "scale=6; $hue * 60" | bc)

        # Normalize hue to [0-360]
        if (( $(echo "$hue < 0" | bc -l) )); then
            hue=$(echo "scale=6; $hue + 360" | bc)
        fi
    fi

    # Convert to output format: H [0-360], S [0-100], L [0-100]
    local h_out=$(echo "scale=2; $hue" | bc)
    local s_out=$(echo "scale=2; $saturation * 100" | bc)
    local l_out=$(echo "scale=2; $lightness * 100" | bc)

    echo "$h_out $s_out $l_out"
}

# Calculate angular distance between two hues (0-360 degrees)
hue_distance() {
    local h1=$1
    local h2=$2

    # Calculate absolute difference
    local diff=$(echo "scale=6; $h1 - $h2" | bc)
    if (( $(echo "$diff < 0" | bc -l) )); then
        diff=$(echo "scale=6; -1 * $diff" | bc)
    fi

    # Calculate circular distance (shortest path around the color wheel)
    local circular_diff=$(echo "scale=6; 360 - $diff" | bc)

    # Return the smaller distance
    if (( $(echo "$diff <= $circular_diff" | bc -l) )); then
        echo "$diff"
    else
        echo "$circular_diff"
    fi
}

# Calculate euclidean distance between two RGB colors (kept for compatibility)
color_distance_euclidean() {
    local r1=$1 g1=$2 b1=$3
    local r2=$4 g2=$5 b2=$6

    local dr=$((r1 - r2))
    local dg=$((g1 - g2))
    local db=$((b1 - b2))

    # Euclidean distance formula: sqrt((r1-r2)¬≤ + (g1-g2)¬≤ + (b1-b2)¬≤)
    local distance_squared=$((dr*dr + dg*dg + db*db))
    echo "$distance_squared"
}

# Calculate color brightness (perceived luminance)
color_brightness() {
    local r=$1 g=$2 b=$3
    # Using ITU-R BT.709 formula for perceived brightness
    local brightness=$(echo "scale=2; 0.2126*$r + 0.7152*$g + 0.0722*$b" | bc)
    echo "$brightness"
}

# Get color temperature (warm vs cool)
color_temperature() {
    local r=$1 g=$2 b=$3
    # Simple temperature calculation: red-heavy = warm, blue-heavy = cool
    local temp_score=$(echo "scale=2; ($r - $b) / 255" | bc)
    echo "$temp_score"
}

# Get all available colors from xrdb
get_xrdb_colors() {
    declare -A colors

    # Get standard colors 0-15
    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null)
        if [[ -n "$color" ]]; then
            colors["color$i"]="$color"
        fi
    done

    # Get special colors
    local bg=$(xrdb -get "background" 2>/dev/null)
    local fg=$(xrdb -get "foreground" 2>/dev/null)

    [[ -n "$bg" ]] && colors["background"]="$bg"
    [[ -n "$fg" ]] && colors["foreground"]="$fg"

    # Return as key=value pairs
    for key in "${!colors[@]}"; do
        echo "$key=${colors[$key]}"
    done
}

# Find best color for a specific concept
find_best_color_for_concept() {
    local concept="$1"
    local target_r target_g target_b
    local preference_order=()

    case "$concept" in
        "error"|"danger")
            target_r=255; target_g=0; target_b=0  # Pure red
            preference_order=(9 1 11 5 13 3)  # bright red, red, yellow, magenta, bright magenta, dark yellow
            ;;
        "warning"|"caution")
            target_r=255; target_g=165; target_b=0  # Orange
            preference_order=(11 3 9 1 13)  # yellow, dark yellow, bright red, red, bright magenta
            ;;
        "success"|"ok")
            target_r=0; target_g=255; target_b=0  # Pure green
            preference_order=(10 2 11 6 14)  # bright green, green, yellow, cyan, bright cyan
            ;;
        "info"|"neutral")
            target_r=0; target_g=100; target_b=255  # Blue
            preference_order=(12 4 6 14 10)  # bright blue, blue, cyan, bright cyan, bright green
            ;;
        "accent"|"highlight")
            target_r=128; target_g=0; target_b=255  # Purple/Violet
            preference_order=(13 5 14 12 9)  # bright magenta, magenta, bright cyan, bright blue, bright red
            ;;
        "red")
            target_r=255; target_g=0; target_b=0  # Pure red
            preference_order=(9 1 5 13 11)  # bright red, red, magenta, bright magenta, yellow
            ;;
        "green")
            target_r=0; target_g=255; target_b=0  # Pure green
            preference_order=(10 2 6 14 11)  # bright green, green, cyan, bright cyan, yellow
            ;;
        "blue")
            target_r=0; target_g=0; target_b=255  # Pure blue
            preference_order=(12 4 6 14 13)  # bright blue, blue, cyan, bright cyan, bright magenta
            ;;
        "yellow")
            target_r=255; target_g=255; target_b=0  # Pure yellow
            preference_order=(11 3 10 9 1)  # bright yellow, dark yellow, bright green, bright red, red
            ;;
        "cyan")
            target_r=0; target_g=255; target_b=255  # Pure cyan
            preference_order=(14 6 12 4 10)  # bright cyan, cyan, bright blue, blue, bright green
            ;;
        "magenta"|"purple")
            target_r=255; target_g=0; target_b=255  # Pure magenta
            preference_order=(13 5 9 1 12)  # bright magenta, magenta, bright red, red, bright blue
            ;;
        "orange")
            target_r=255; target_g=165; target_b=0  # Orange
            preference_order=(11 3 9 1 10)  # bright yellow, dark yellow, bright red, red, bright green
            ;;
        "pink")
            target_r=255; target_g=192; target_b=203  # Pink
            preference_order=(13 5 9 11 1)  # bright magenta, magenta, bright red, bright yellow, red
            ;;
        "brown")
            target_r=165; target_g=42; target_b=42  # Brown
            preference_order=(1 9 3 11 8)  # red, bright red, dark yellow, bright yellow, dark gray
            ;;
        "white")
            target_r=255; target_g=255; target_b=255  # Pure white
            preference_order=(15 7 14 6 11)  # bright white, light gray, bright cyan, cyan, bright yellow
            ;;
        "black")
            target_r=0; target_g=0; target_b=0  # Pure black
            preference_order=(0 8 4 2 1)  # black, dark gray, dark blue, dark green, red
            ;;
        "gray"|"grey")
            target_r=128; target_g=128; target_b=128  # Gray
            preference_order=(8 7 4 2 6)  # dark gray, light gray, dark blue, dark green, cyan
            ;;
        *)
            show_error "Unknown concept: $concept"
            echo "Available concepts:"
            echo "  Semantic: error, warning, success, info, accent"
            echo "  Colors: red, green, blue, yellow, cyan, magenta, orange, pink, brown, white, black, gray"
            return 1
            ;;
    esac

    local best_color=""
    local best_distance=999.0  # High initial value for composite distance metric
    local best_source=""

    # First, try preference order
    for color_num in "${preference_order[@]}"; do
        local color=$(xrdb -get "color$color_num" 2>/dev/null)
        if [[ -n "$color" && "$color" != "#000000" ]]; then
            best_color="$color"
            best_source="color$color_num"
            break
        fi
    done

    # If no preference color found, calculate perceptual distances
    if [[ -z "$best_color" ]]; then
        # Get target hue from target RGB
        local target_hex=$(printf "#%02x%02x%02x" "$target_r" "$target_g" "$target_b")
        local target_hsl=$(hex_to_hsl "$target_hex")
        local target_hue target_sat target_light
        read -r target_hue target_sat target_light <<< "$target_hsl"

        while IFS= read -r line; do
            local key="${line%=*}"
            local color="${line#*=}"

            # Skip background and foreground for most concepts
            [[ "$key" == "background" || "$key" == "foreground" ]] && continue

            if [[ -n "$color" ]]; then
                # Get HSL of the current color
                local color_hsl=$(hex_to_hsl "$color")
                local color_hue color_sat color_light
                read -r color_hue color_sat color_light <<< "$color_hsl"

                # Filter out colors with low saturation or extreme lightness
                # Skip grays and washed-out colors (sat < 20) and very dark/light colors
                if (( $(echo "$color_sat < 20" | bc -l) )) || \
                   (( $(echo "$color_light < 20" | bc -l) )) || \
                   (( $(echo "$color_light > 90" | bc -l) )); then
                    continue
                fi

                # Calculate composite perceptual distance
                # Hue distance (most important, weight = 1.0)
                local hue_dist=$(hue_distance "$target_hue" "$color_hue")

                # Saturation penalty (ideal saturation ~80%, weight = 0.3)
                local ideal_sat=80
                local sat_penalty=$(echo "scale=6; ($color_sat - $ideal_sat)" | bc)
                if (( $(echo "$sat_penalty < 0" | bc -l) )); then
                    sat_penalty=$(echo "scale=6; -1 * $sat_penalty" | bc)
                fi
                sat_penalty=$(echo "scale=6; $sat_penalty * 0.3" | bc)

                # Lightness penalty (ideal lightness ~50%, weight = 0.2)
                local ideal_light=50
                local light_penalty=$(echo "scale=6; ($color_light - $ideal_light)" | bc)
                if (( $(echo "$light_penalty < 0" | bc -l) )); then
                    light_penalty=$(echo "scale=6; -1 * $light_penalty" | bc)
                fi
                light_penalty=$(echo "scale=6; $light_penalty * 0.2" | bc)

                # Composite distance: hue_distance + saturation_penalty + lightness_penalty
                local composite_distance=$(echo "scale=6; $hue_dist + $sat_penalty + $light_penalty" | bc)

                # Convert to integer for comparison (multiply by 1000 to preserve precision)
                local distance_int=$(echo "scale=0; $composite_distance * 1000" | bc)
                local best_distance_int=$(echo "scale=0; $best_distance * 1000" | bc)

                if [[ "$distance_int" -lt "$best_distance_int" ]]; then
                    best_distance="$composite_distance"
                    best_color="$color"
                    best_source="$key"
                fi
            fi
        done < <(get_xrdb_colors)
    fi

    case "${format:-hex}" in
        "hex")
            echo "$best_color"
            ;;
        "rgb")
            hex_to_rgb "$best_color"
            ;;
        "polybar")
            echo "\${xrdb:$best_source}"
            ;;
        *)
            echo "$best_color"
            ;;
    esac

    [[ -n "$verbose" ]] && show_info "Best $concept color: $best_color (from $best_source)"
}

# Analyze complete palette
analyze_palette() {
    show_status "Analyzing current color palette..."
    echo

    # Show visual palette first
    show_palette_visual

    # Show current palette (text format)
    echo -e "${BOLD}Current Palette (Text):${NC}"
    while IFS= read -r line; do
        local key="${line%=*}"
        local color="${line#*=}"
        echo "  $key: $color"
    done < <(get_xrdb_colors)

    echo
    echo -e "${BOLD}Semantic Color Recommendations:${NC}"

    # Get recommendations for each concept
    local semantic_concepts=("error" "warning" "success" "info" "accent")
    for concept in "${semantic_concepts[@]}"; do
        local recommended_color=$(find_best_color_for_concept "$concept")
        show_color_block "$recommended_color" "$concept" 6
    done

    echo
    echo -e "${BOLD}Basic Color Recommendations:${NC}"

    # Get recommendations for basic colors
    local basic_colors=("red" "green" "blue" "yellow" "cyan" "magenta" "orange" "pink")
    for color in "${basic_colors[@]}"; do
        local recommended_color=$(find_best_color_for_concept "$color")
        show_color_block "$recommended_color" "$color" 6
    done

    echo
    echo -e "${BOLD}Palette Analysis:${NC}"

    # Analyze palette characteristics
    local warm_colors=0
    local cool_colors=0
    local bright_colors=0
    local dark_colors=0

    while IFS= read -r line; do
        local color="${line#*=}"
        [[ "$color" =~ ^#[0-9a-fA-F]{6}$ ]] || continue

        local rgb=$(hex_to_rgb "$color")
        local r g b
        read -r r g b <<< "$rgb"

        local brightness=$(color_brightness "$r" "$g" "$b")
        local temperature=$(color_temperature "$r" "$g" "$b")

        if (( $(echo "$temperature > 0" | bc -l) )); then
            ((warm_colors++))
        else
            ((cool_colors++))
        fi

        if (( $(echo "$brightness > 128" | bc -l) )); then
            ((bright_colors++))
        else
            ((dark_colors++))
        fi
    done < <(get_xrdb_colors)

    echo "  Warm colors: $warm_colors | Cool colors: $cool_colors"
    echo "  Bright colors: $bright_colors | Dark colors: $dark_colors"

    # Theme type suggestion
    if [[ "$warm_colors" -gt "$cool_colors" ]]; then
        echo "  Theme tendency: Warm palette üî•"
    else
        echo "  Theme tendency: Cool palette ‚ùÑÔ∏è"
    fi
}

# Export color variables
export_colors() {
    show_status "Exporting smart color variables..."

    echo "# Smart color variables generated by dots-smart-colors"
    echo "# Source this file or copy to your shell/polybar config"
    echo

    echo "# Semantic colors"
    local semantic_concepts=("error" "warning" "success" "info" "accent")
    for concept in "${semantic_concepts[@]}"; do
        local color=$(find_best_color_for_concept "$concept")
        echo "export SMART_COLOR_${concept^^}='$color'"
    done

    echo
    echo "# Basic colors"
    local basic_colors=("red" "green" "blue" "yellow" "cyan" "magenta" "orange" "pink" "brown" "white" "black" "gray")
    for color in "${basic_colors[@]}"; do
        local color_value=$(find_best_color_for_concept "$color")
        echo "export SMART_COLOR_${color^^}='$color_value'"
    done

    echo
    echo "# Polybar format variables (semantic)"
    for concept in "${semantic_concepts[@]}"; do
        local color=$(format="polybar" find_best_color_for_concept "$concept")
        echo "# smart-$concept = $color"
    done

    echo
    echo "# Polybar format variables (basic colors)"
    for color in "${basic_colors[@]}"; do
        local color_value=$(format="polybar" find_best_color_for_concept "$color")
        echo "# smart-$color = $color_value"
    done
}

# Export EWW SCSS color variables
export_eww_scss() {
    show_status "Generating EWW SCSS color variables..."

    echo "/* EWW SCSS color variables generated by dots-smart-colors */"
    echo "/* Auto-generated - do not edit manually */"
    echo

    # Export base colors from xrdb
    echo "/* Base colors from X resources */"
    local bg=$(xrdb -get "background" 2>/dev/null || echo "#000000")
    local fg=$(xrdb -get "foreground" 2>/dev/null || echo "#ffffff")

    echo "\$background: $bg;"
    echo "\$foreground: $fg;"
    echo

    # Export all base16 colors
    echo "/* Base16 color palette */"
    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null || echo "#000000")
        echo "\$color$i: $color;"
    done

    echo
    echo "/* Smart semantic colors (theme-adaptive) */"
    local semantic_concepts=("error" "warning" "success" "info" "accent")
    for concept in "${semantic_concepts[@]}"; do
        local color=$(find_best_color_for_concept "$concept")
        echo "\$smart-$concept: $color;"
    done

    echo
    echo "/* Smart basic colors (theme-adaptive) */"
    local basic_colors=("red" "green" "blue" "yellow" "cyan" "magenta" "orange" "pink")
    for color in "${basic_colors[@]}"; do
        local color_value=$(find_best_color_for_concept "$color")
        echo "\$smart-$color: $color_value;"
    done

    echo
    echo "/* Compatibility aliases for existing EWW configs */"
    echo "\$wallpaper: url('\$HOME/.cache/wal/wallpaper');"
}

# Export i3 color variables
export_i3_colors() {
    show_status "Generating i3 color variables..."

    echo "# i3 color variables generated by dots-smart-colors"
    echo "# Auto-generated - do not edit manually"
    echo

    echo "# Base colors from X resources"
    for i in {0..15}; do
        local color=$(xrdb -get "color$i" 2>/dev/null || echo "#000000")
        printf "set \$base%02X %s\n" "$i" "$color"
    done

    echo
    echo "# Smart semantic colors (theme-adaptive)"
    local concepts=("error" "warning" "success" "info" "accent")
    for concept in "${concepts[@]}"; do
        local color=$(find_best_color_for_concept "$concept")
        echo "set \$smart_$concept $color"
    done

    echo
    echo "# Smart basic colors (theme-adaptive)"
    local colors=("red" "green" "blue" "yellow" "cyan" "magenta")
    for color in "${colors[@]}"; do
        local color_value=$(find_best_color_for_concept "$color")
        echo "set \$smart_$color $color_value"
    done

    echo
    echo "# Recommended i3 color scheme using smart colors"
    echo "# client.focused          \$smart_accent  \$smart_accent  \$background     \$smart_info    \$smart_accent"
    echo "# client.focused_inactive \$background    \$background    \$foreground     \$background    \$background"
    echo "# client.unfocused        \$background    \$background    \$foreground     \$background    \$background"
    echo "# client.urgent           \$smart_error   \$smart_error   \$background     \$smart_error   \$smart_error"
}

# Main script logic
main() {
    # Check dependencies
    if ! command -v xrdb >/dev/null 2>&1; then
        show_error "xrdb command not found. Please install X11 utilities."
        exit 1
    fi

    if ! command -v bc >/dev/null 2>&1; then
        show_error "bc command not found. Please install bc for calculations."
        exit 1
    fi

    # Handle options
    if [[ -n "$analyze" ]]; then
        analyze_palette
    elif [[ -n "$colors" ]]; then
        show_palette_visual
    elif [[ -n "$export" ]]; then
        case "${format:-shell}" in
            "eww"|"scss")
                export_eww_scss
                ;;
            "i3")
                export_i3_colors
                ;;
            *)
                export_colors
                ;;
        esac
    elif [[ -n "$concept" ]]; then
        find_best_color_for_concept "$concept"
    else
        # Default: show quick analysis with visual colors
        show_status "Quick palette analysis (use --analyze for detailed view)"
        echo

        echo -e "${BOLD}Semantic Colors:${NC}"
        local semantic_concepts=("error" "warning" "success" "info" "accent")
        for concept in "${semantic_concepts[@]}"; do
            local color=$(find_best_color_for_concept "$concept")
            show_color_block "$color" "$concept" 6
        done

        echo
        echo -e "${BOLD}Basic Colors:${NC}"
        local basic_colors=("red" "green" "blue" "yellow" "cyan" "magenta")
        for color in "${basic_colors[@]}"; do
            local color_value=$(find_best_color_for_concept "$color")
            show_color_block "$color_value" "$color" 6
        done

        echo
        echo -e "${BOLD}Compact Palette:${NC}"
        # Show current palette in compact view
        local color_line=""
        local reset="\033[0m"

        for i in {0..15}; do
            local palette_color=$(xrdb -get "color$i" 2>/dev/null)
            if [[ -n "$palette_color" ]]; then
                local ansi_bg=$(hex_to_ansi_bg "$palette_color")
                color_line+="${ansi_bg}  ${reset}"
            fi
        done

        echo -e "$color_line"

        echo
        show_info "Use 'dots-smart-colors --help' for more options"
        show_info "Use 'dots-smart-colors --colors' to see full visual palette"
        show_info "Available concepts: error, warning, success, info, accent, red, green, blue, yellow, cyan, magenta, orange, pink, brown, white, black, gray"
    fi
}

# Run main function
main "$@"
