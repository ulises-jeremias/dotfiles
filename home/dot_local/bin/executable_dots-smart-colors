#!/usr/bin/env bash

## Copyright (C) 2019-2025 Ulises Jeremias Cornejo Fandos
## Licensed under MIT.
##
## Smart color palette analyzer and theme-adaptive color selector
## Analyzes your current X resources color palette and intelligently selects optimal colors
## for different semantic concepts (error, warning, success, info, etc.) with enhanced contrast
## and Material Design inspired choices that adapt beautifully to light and dark themes.
##
## Usage:
##     @script.name [OPTION] ARGUMENTS...
##
## Options:
##     -h, --help                            Show this help message.
##     -a, --analyze                         Analyze current palette and show recommendations.
##     -c, --colors                          Show visual color palette with blocks.
##     -e, --export                          Export color variables for shell usage.
##         --concept=CONCEPT                 Get best color for specific concept (error|warning|success|info|accent|red|green|blue|yellow|cyan|magenta|orange|pink|brown|white|black|gray|background|background-alt|foreground|foreground-alt).
##         --format=FORMAT                   Output format: hex, rgb, eww, scss, files (default: hex).
##         --generate                        Generate all smart color files in ~/.cache/dots/smart-colors/.
##     -v, --verbose                         Show detailed analysis.

set -euo pipefail

source ~/.local/lib/dots/easy-options/easyoptions.sh || exit 1

# Output colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# File paths
readonly CACHE_DIR="${HOME}/.cache/dots"
readonly SMART_COLORS_DIR="${CACHE_DIR}/smart-colors"
readonly EWW_COLORS_FILE="${SMART_COLORS_DIR}/colors-eww.scss"
readonly SHELL_COLORS_FILE="${SMART_COLORS_DIR}/colors.sh"
readonly ENV_COLORS_FILE="${SMART_COLORS_DIR}/colors.env"

# Status functions
show_status() { echo -e "${CYAN}ðŸŽ¨${NC} $1"; }
show_success() { echo -e "${GREEN}âœ…${NC} $1"; }
show_error() { echo -e "${RED}âŒ${NC} $1"; }
show_info() { echo -e "${BLUE}â„¹ï¸${NC} $1"; }

# Convert hex to RGB values
hex_to_rgb() {
  local hex="${1#\#}"
  echo $((16#${hex:0:2})) $((16#${hex:2:2})) $((16#${hex:4:2}))
}

# Calculate luminance of a color (0-255 scale)
calculate_luminance() {
  local color="$1"
  local hex="${color#\#}"
  local red=$((16#${hex:0:2}))
  local green=$((16#${hex:2:2}))
  local blue=$((16#${hex:4:2}))

  # Calculate relative luminance using standard formula
  # Using simplified integer math for performance
  echo $(((red * 299 + green * 587 + blue * 114) / 1000))
}

# Detect if current theme is light or dark based on background
is_light_theme() {
  local bg_color
  bg_color=$(xrdb -get "background" 2>/dev/null || echo "#000000")
  local luminance
  luminance=$(calculate_luminance "$bg_color")

  # Threshold: >128 is considered light theme (out of 255)
  [[ $luminance -gt 128 ]]
}

# Get optimal foreground color for current theme
get_optimal_foreground() {
  local original_fg
  original_fg=$(xrdb -get "foreground" 2>/dev/null || echo "#ffffff")

  if is_light_theme; then
    # In light themes, use a softer foreground instead of pure black
    local color5
    color5=$(xrdb -get "color5" 2>/dev/null || echo "#52758A")
    local color7
    color7=$(xrdb -get "color7" 2>/dev/null || echo "#0f1415")

    # Prefer color5 if available, fallback to color7, then original foreground
    if [[ -n $color5 && $color5 != "#000000" ]]; then
      echo "$color5"
    elif [[ -n $color7 && $color7 != "#000000" ]]; then
      echo "$color7"
    else
      echo "$original_fg"
    fi
  else
    # In dark themes, use original foreground
    echo "$original_fg"
  fi
}

# Convert hex to ANSI background color for terminal display
hex_to_ansi_bg() {
  local rgb
  rgb=$(hex_to_rgb "$1")
  echo "\033[48;2;${rgb// /;}m"
}

# Show color block in terminal
show_color_block() {
  local hex="$1" label="$2" width="${3:-8}"
  local ansi_bg
  ansi_bg=$(hex_to_ansi_bg "$hex")
  local spaces
  printf -v spaces "%*s" "$width" ""
  printf "${ansi_bg}${spaces}${NC} %-10s %s\n" "$label" "$hex"
}

# Detect palette's dominant color tendency
get_palette_dominant_color() {
  local brightest_color="" brightest_value=0

  # Check bright colors (9-14) for dominant hue
  for i in {9..14}; do
    local color
    color=$(xrdb -get "color$i" 2>/dev/null) || continue
    local hex="${color#\#}"
    local red=$((16#${hex:0:2})) green=$((16#${hex:2:2})) blue=$((16#${hex:4:2}))
    local brightness=$((red + green + blue))

    if [[ $brightness -gt $brightest_value ]]; then
      brightest_value=$brightness
      brightest_color="$color"
    fi
  done

  # Classify hue based on RGB dominance
  if [[ -n $brightest_color ]]; then
    local hex="${brightest_color#\#}"
    local red=$((16#${hex:0:2})) green=$((16#${hex:2:2})) blue=$((16#${hex:4:2}))

    if [[ $red -gt $green && $red -gt $blue ]]; then
      [[ $green -gt 100 ]] && echo "orange" || [[ $blue -gt 100 ]] && echo "purple" || echo "red"
    elif [[ $green -gt $red && $green -gt $blue ]]; then
      [[ $red -gt 100 ]] && echo "yellow" || [[ $blue -gt 100 ]] && echo "cyan" || echo "green"
    elif [[ $blue -gt $red && $blue -gt $green ]]; then
      [[ $red -gt 100 ]] && echo "purple" || [[ $green -gt 100 ]] && echo "cyan" || echo "blue"
    else
      echo "gray"
    fi
  else
    echo "unknown"
  fi
}

# Get palette average color for harmonization
get_palette_average() {
  local total_red=0 total_green=0 total_blue=0 color_count=0

  for i in {1..14}; do
    local color
    color=$(xrdb -get "color$i" 2>/dev/null) || continue
    local hex="${color#\#}"
    local red=$((16#${hex:0:2})) green=$((16#${hex:2:2})) blue=$((16#${hex:4:2}))

    total_red=$((total_red + red))
    total_green=$((total_green + green))
    total_blue=$((total_blue + blue))
    ((color_count++))
  done

  if [[ $color_count -gt 0 ]]; then
    local avg_red=$((total_red / color_count))
    local avg_green=$((total_green / color_count))
    local avg_blue=$((total_blue / color_count))
    printf "#%02x%02x%02x" "$avg_red" "$avg_green" "$avg_blue"
  else
    echo "#808080"
  fi
}

# Enhanced color blending for better harmony and contrast
enhance_color_contrast() {
  local color="$1" concept="$2"
  local background_color
  background_color=$(xrdb -get "background" 2>/dev/null || echo "#000000")
  local bg_luminance
  bg_luminance=$(calculate_luminance "$background_color")

  # For light themes, ensure colors are dark enough for good contrast
  if is_light_theme; then
    # Ensure minimum contrast ratio for readability
    local color_luminance
    color_luminance=$(calculate_luminance "$color")

    # If color is too light for a light theme, darken it
    if [[ $color_luminance -gt 180 ]]; then
      # Darken the color by reducing RGB values
      local hex="${color#\#}"
      local red=$((16#${hex:0:2})) green=$((16#${hex:2:2})) blue=$((16#${hex:4:2}))

      # Reduce brightness by 30-40% for better contrast
      red=$(((red * 60) / 100))
      green=$(((green * 60) / 100))
      blue=$(((blue * 60) / 100))

      printf "#%02x%02x%02x" "$red" "$green" "$blue"
    else
      echo "$color"
    fi
  else
    # For dark themes, ensure colors are bright enough
    local color_luminance
    color_luminance=$(calculate_luminance "$color")

    # If color is too dark for a dark theme, brighten it slightly
    if [[ $color_luminance -lt 80 ]]; then
      # Brighten the color
      local hex="${color#\#}"
      local red=$((16#${hex:0:2})) green=$((16#${hex:2:2})) blue=$((16#${hex:4:2}))

      # Increase brightness by 20-30%
      red=$(((red * 130) / 100))
      green=$(((green * 130) / 100))
      blue=$(((blue * 130) / 100))

      # Clamp to max 255
      [[ $red -gt 255 ]] && red=255
      [[ $green -gt 255 ]] && green=255
      [[ $blue -gt 255 ]] && blue=255

      printf "#%02x%02x%02x" "$red" "$green" "$blue"
    else
      echo "$color"
    fi
  fi
}

# Blend two colors with specified percentage
blend_colors() {
  local color1="$1" color2="$2" blend_percent="$3"

  local hex1="${color1#\#}" hex2="${color2#\#}"
  local red1=$((16#${hex1:0:2})) green1=$((16#${hex1:2:2})) blue1=$((16#${hex1:4:2}))
  local red2=$((16#${hex2:0:2})) green2=$((16#${hex2:2:2})) blue2=$((16#${hex2:4:2}))

  local inverse_percent=$((100 - blend_percent))
  local result_red=$(((red1 * inverse_percent + red2 * blend_percent) / 100))
  local result_green=$(((green1 * inverse_percent + green2 * blend_percent) / 100))
  local result_blue=$(((blue1 * inverse_percent + blue2 * blend_percent) / 100))

  # Clamp to 0-255
  [[ $result_red -gt 255 ]] && result_red=255 || [[ $result_red -lt 0 ]] && result_red=0
  [[ $result_green -gt 255 ]] && result_green=255 || [[ $result_green -lt 0 ]] && result_green=0
  [[ $result_blue -gt 255 ]] && result_blue=255 || [[ $result_blue -lt 0 ]] && result_blue=0

  printf "#%02x%02x%02x" "$result_red" "$result_green" "$result_blue"
}

# CORE FUNCTION: Semantic color lookup table with palette adaptation and theme awareness
get_smart_color() {
  local concept="$1"
  local palette_dominant="${2:-unknown}"

  # Handle neutrals separately (don't need palette adaptation)
  case "$concept" in
    white)
      xrdb -get "foreground" 2>/dev/null || echo "#ffffff"
      return
      ;;
    black)
      xrdb -get "background" 2>/dev/null || echo "#000000"
      return
      ;;
    gray | grey)
      xrdb -get "color8" 2>/dev/null || echo "#808080"
      return
      ;;
  esac

  # Detect if current theme is light or dark for adaptive color selection
  local theme_type
  if is_light_theme; then
    theme_type="light"
  else
    theme_type="dark"
  fi

  # Enhanced lookup table: concept|theme|palette_tendency -> semantically correct color
  # NEW: Better contrast ratios and more beautiful color selections
  case "$concept|$theme_type|$palette_dominant" in
    # ERROR (always reddish) - Enhanced contrast for better readability
    "error|dark|red") echo "#ff6b6b" ;;    # More vibrant red for dark themes
    "error|dark|orange") echo "#ff5722" ;; # Orange-red blend
    "error|dark|purple") echo "#e91e63" ;; # Pink-red for purple themes
    "error|dark|"*) echo "#f44336" ;;      # Material red default

    "error|light|red") echo "#d32f2f" ;;    # Darker red for light themes
    "error|light|orange") echo "#bf360c" ;; # Deep orange-red
    "error|light|purple") echo "#ad1457" ;; # Deep pink-red
    "error|light|"*) echo "#c62828" ;;      # Darker material red

    # WARNING (always orange/yellow) - Better harmony with backgrounds
    "warning|dark|orange") echo "#ff9800" ;; # Vibrant orange
    "warning|dark|yellow") echo "#ffc107" ;; # Amber for visibility
    "warning|dark|red") echo "#ff7043" ;;    # Orange-red warning
    "warning|dark|"*) echo "#ff8f00" ;;      # Golden orange

    "warning|light|orange") echo "#ef6c00" ;; # Deep orange
    "warning|light|yellow") echo "#f57f17" ;; # Dark amber
    "warning|light|red") echo "#d84315" ;;    # Deep orange-red
    "warning|light|"*) echo "#e65100" ;;      # Dark orange

    # SUCCESS (always greenish) - Enhanced natural greens
    "success|dark|green") echo "#4caf50" ;; # Material green
    "success|dark|cyan") echo "#00bcd4" ;;  # Cyan-green for freshness
    "success|dark|blue") echo "#2196f3" ;;  # Blue-green alternative
    "success|dark|"*) echo "#8bc34a" ;;     # Light green default

    "success|light|green") echo "#2e7d32" ;; # Dark forest green
    "success|light|cyan") echo "#00838f" ;;  # Dark cyan-green
    "success|light|blue") echo "#1565c0" ;;  # Dark blue alternative
    "success|light|"*) echo "#689f38" ;;     # Olive green

    # INFO (bluish/cyan) - Better contrast and readability
    "info|dark|blue") echo "#2196f3" ;;   # Material blue
    "info|dark|cyan") echo "#00bcd4" ;;   # Bright cyan
    "info|dark|purple") echo "#9c27b0" ;; # Purple-blue
    "info|dark|"*) echo "#03a9f4" ;;      # Light blue default

    "info|light|blue") echo "#1976d2" ;;   # Dark blue
    "info|light|cyan") echo "#0097a7" ;;   # Dark cyan
    "info|light|purple") echo "#7b1fa2" ;; # Dark purple
    "info|light|"*) echo "#0288d1" ;;      # Medium blue

    # ACCENT (distinctive highlight) - More vibrant and theme-adaptive
    "accent|dark|purple") echo "#9c27b0" ;; # Vibrant purple
    "accent|dark|pink") echo "#e91e63" ;;   # Material pink
    "accent|dark|orange") echo "#ff5722" ;; # Deep orange
    "accent|dark|"*) echo "#673ab7" ;;      # Deep purple default

    "accent|light|purple") echo "#6a1b9a" ;; # Dark purple
    "accent|light|pink") echo "#c2185b" ;;   # Dark pink
    "accent|light|orange") echo "#d84315" ;; # Dark orange
    "accent|light|"*) echo "#512da8" ;;      # Dark purple

    # BASIC COLORS (maintain identity) - Better theme adaptation
    "red|dark|red") echo "#f44336" ;;    # Material red
    "red|dark|orange") echo "#ff5722" ;; # Orange-red
    "red|dark|"*) echo "#e53935" ;;      # Bright red

    "red|light|red") echo "#d32f2f" ;;    # Dark red
    "red|light|orange") echo "#bf360c" ;; # Dark orange-red
    "red|light|"*) echo "#c62828" ;;      # Deep red

    "green|dark|green") echo "#4caf50" ;; # Material green
    "green|dark|cyan") echo "#26a69a" ;;  # Teal green
    "green|dark|"*) echo "#66bb6a" ;;     # Light green

    "green|light|green") echo "#388e3c" ;; # Dark green
    "green|light|cyan") echo "#00695c" ;;  # Dark teal
    "green|light|"*) echo "#2e7d32" ;;     # Forest green

    "blue|dark|blue") echo "#2196f3" ;; # Material blue
    "blue|dark|cyan") echo "#00bcd4" ;; # Cyan-blue
    "blue|dark|"*) echo "#42a5f5" ;;    # Light blue

    "blue|light|blue") echo "#1976d2" ;; # Dark blue
    "blue|light|cyan") echo "#0097a7" ;; # Dark cyan
    "blue|light|"*) echo "#1565c0" ;;    # Deep blue

    "yellow|dark|yellow") echo "#ffeb3b" ;; # Bright yellow
    "yellow|dark|orange") echo "#ffc107" ;; # Amber
    "yellow|dark|"*) echo "#ffca28" ;;      # Golden yellow

    "yellow|light|yellow") echo "#f57f17" ;; # Dark yellow
    "yellow|light|orange") echo "#ef6c00" ;; # Dark amber
    "yellow|light|"*) echo "#f9a825" ;;      # Dark golden

    "cyan|dark|cyan") echo "#00bcd4" ;; # Material cyan
    "cyan|dark|blue") echo "#03a9f4" ;; # Cyan-blue
    "cyan|dark|"*) echo "#26c6da" ;;    # Light cyan

    "cyan|light|cyan") echo "#00838f" ;; # Dark cyan
    "cyan|light|blue") echo "#0277bd" ;; # Dark cyan-blue
    "cyan|light|"*) echo "#00695c" ;;    # Teal

    "magenta|dark|purple" | "purple|dark|purple") echo "#9c27b0" ;; # Material purple
    "magenta|dark|pink" | "purple|dark|pink") echo "#e91e63" ;;     # Material pink
    "magenta|dark|"* | "purple|dark|"*) echo "#ab47bc" ;;           # Light purple

    "magenta|light|purple" | "purple|light|purple") echo "#7b1fa2" ;; # Dark purple
    "magenta|light|pink" | "purple|light|pink") echo "#ad1457" ;;     # Dark pink
    "magenta|light|"* | "purple|light|"*) echo "#8e24aa" ;;           # Medium purple

    "orange|dark|orange") echo "#ff9800" ;; # Material orange
    "orange|dark|red") echo "#ff5722" ;;    # Deep orange
    "orange|dark|"*) echo "#ffb74d" ;;      # Light orange

    "orange|light|orange") echo "#f57c00" ;; # Dark orange
    "orange|light|red") echo "#d84315" ;;    # Dark deep orange
    "orange|light|"*) echo "#ef6c00" ;;      # Medium orange

    "pink|dark|pink") echo "#e91e63" ;;   # Material pink
    "pink|dark|purple") echo "#9c27b0" ;; # Pink-purple
    "pink|dark|"*) echo "#f06292" ;;      # Light pink

    "pink|light|pink") echo "#c2185b" ;;   # Dark pink
    "pink|light|purple") echo "#7b1fa2" ;; # Dark pink-purple
    "pink|light|"*) echo "#ad1457" ;;      # Deep pink

    "brown|dark|red") echo "#8d6e63" ;;    # Material brown
    "brown|dark|orange") echo "#a1887f" ;; # Light brown
    "brown|dark|"*) echo "#795548" ;;      # Dark brown

    "brown|light|red") echo "#5d4037" ;;    # Dark brown
    "brown|light|orange") echo "#6d4c41" ;; # Deep brown
    "brown|light|"*) echo "#4e342e" ;;      # Very dark brown

    # FALLBACKS - Enhanced contrast
    "dark|"*) echo "#bdbdbd" ;;  # Light gray for dark themes
    "light|"*) echo "#424242" ;; # Dark gray for light themes
    *) echo "#757575" ;;         # Medium gray default
  esac
}

# Main function: Find best color for concept
find_best_color_for_concept() {
  local concept="$1"

  # Validate concept
  case "$concept" in
    error | warning | success | info | accent | red | green | blue | yellow | cyan | magenta | purple | orange | pink | brown | white | black | gray | grey | background | background-alt | foreground | foreground-alt) ;;
    *)
      show_error "Unknown concept: $concept"
      return 1
      ;;
  esac

  # Handle neutrals and background/foreground variants directly
  case "$concept" in
    white | black | gray | grey)
      get_smart_color "$concept"
      return 0
      ;;
    background)
      xrdb -get "background" 2>/dev/null || echo "#000000"
      return 0
      ;;
    background-alt)
      xrdb -get "color1" 2>/dev/null || echo "#1a1a1a"
      return 0
      ;;
    foreground)
      get_optimal_foreground
      return 0
      ;;
    foreground-alt)
      xrdb -get "color5" 2>/dev/null || echo "#888888"
      return 0
      ;;
  esac

  # Get palette characteristics
  local dominant_color
  dominant_color=$(get_palette_dominant_color)
  local palette_average
  palette_average=$(get_palette_average)

  # Get base semantic color using enhanced algorithm
  local base_color
  base_color=$(get_smart_color "$concept" "$dominant_color")

  # Apply contrast enhancement for better readability
  local contrast_enhanced
  contrast_enhanced=$(enhance_color_contrast "$base_color" "$concept")

  # Apply subtle harmonization with palette (10% blend for more natural look)
  local final_color
  final_color=$(blend_colors "$contrast_enhanced" "$palette_average" 10)

  # Format output
  case "${format:-hex}" in
    hex) echo "$final_color" ;;
    rgb) hex_to_rgb "$final_color" ;;
    *) echo "$final_color" ;;
  esac
}

# Show visual palette
show_palette_visual() {
  echo -e "${BOLD}Current Palette:${NC}"

  # Base16 colors
  for i in {0..15}; do
    local color
    color=$(xrdb -get "color$i" 2>/dev/null) || continue
    show_color_block "$color" "color$i"
  done

  echo
  echo -e "${BOLD}ðŸŽ¨ Enhanced Smart Colors (Theme-Adaptive):${NC}"
  echo -e "${BLUE}   Current theme: $(is_light_theme && echo "Light" || echo "Dark")${NC}"
  echo

  echo -e "${BOLD}Smart Background & Foreground:${NC}"
  local bg_fg_colors=(background background-alt foreground foreground-alt)
  for concept in "${bg_fg_colors[@]}"; do
    local color
    color=$(find_best_color_for_concept "$concept")
    show_color_block "$color" "$concept"
  done

  echo
  echo -e "${BOLD}Smart Semantic Colors (Enhanced Contrast):${NC}"
  local concepts=(error warning success info accent)
  for concept in "${concepts[@]}"; do
    local color
    color=$(find_best_color_for_concept "$concept")
    show_color_block "$color" "$concept"
  done

  echo
  echo -e "${BOLD}Smart Basic Colors (Theme-Optimized):${NC}"
  local basic_colors=(red green blue yellow cyan magenta orange pink)
  for color in "${basic_colors[@]}"; do
    local color_value
    color_value=$(find_best_color_for_concept "$color")
    show_color_block "$color_value" "$color"
  done

  echo
  echo -e "${BLUE}ðŸ’¡ Smart Colors Features:${NC}"
  echo -e "   â€¢ Enhanced contrast ratios for better readability"
  echo -e "   â€¢ Material Design inspired color choices"
  echo -e "   â€¢ Automatic theme detection and adaptation"
  echo -e "   â€¢ Harmonized with current palette (10% blend)"
  echo
}

# Generate file outputs
generate_smart_color_files() {
  show_status "Generating smart color files..."
  mkdir -p "$SMART_COLORS_DIR"

  # Generate smart colors
  local error_color
  error_color=$(format="hex" find_best_color_for_concept "error")
  local warning_color
  warning_color=$(format="hex" find_best_color_for_concept "warning")
  local success_color
  success_color=$(format="hex" find_best_color_for_concept "success")
  local info_color
  info_color=$(format="hex" find_best_color_for_concept "info")
  local accent_color
  accent_color=$(format="hex" find_best_color_for_concept "accent")

  # Get palette colors
  local background_color
  background_color=$(xrdb -get "background" 2>/dev/null || echo "#000000")
  local foreground_color
  foreground_color=$(get_optimal_foreground)
  local cursor_color
  cursor_color=$(xrdb -get "cursor" 2>/dev/null)
  if [[ -z $cursor_color ]]; then
    cursor_color="$foreground_color"
  fi

  # Get background and foreground variants
  local background_alt_color
  background_alt_color=$(xrdb -get "color1" 2>/dev/null || echo "#1a1a1a")
  local foreground_alt_color
  foreground_alt_color=$(xrdb -get "color5" 2>/dev/null || echo "#888888")

  local base_colors=()
  for i in {0..15}; do
    base_colors[i]=$(xrdb -get "color$i" 2>/dev/null || echo "#000000")
  done

  # Get wallpaper path
  local wallpaper_path=""
  if [[ -f ~/.cache/wal/wal ]]; then
    wallpaper_path=$(cat ~/.cache/wal/wal)
  elif [[ -f ~/.config/wpg/wp_init.py ]]; then
    wallpaper_path=$(python3 -c "import os; exec(open(os.path.expanduser('~/.config/wpg/wp_init.py')).read()); print(wallpaper)" 2>/dev/null || echo "")
  fi
  [[ -z $wallpaper_path ]] && wallpaper_path="/home/$(whoami)/.wallpaper"

  # Generate EWW colors file
  cat >"$EWW_COLORS_FILE" <<EOF
// SCSS Variables
// Generated by 'dots-smart-colors'
\$wallpaper: "$wallpaper_path";

// Special
\$background: $background_color;
\$foreground: $foreground_color;
\$cursor: $cursor_color;

// Colors
EOF

  for i in {0..15}; do
    echo "\$color$i: ${base_colors[i]};" >>"$EWW_COLORS_FILE"
  done

  cat >>"$EWW_COLORS_FILE" <<EOF

// Background and foreground variants
\$background-alt: $background_alt_color;
\$foreground-alt: $foreground_alt_color;

// Smart semantic colors (theme-adaptive)
\$error: $error_color;
\$warning: $warning_color;
\$success: $success_color;
\$info: $info_color;
\$accent: $accent_color;

// Smart basic colors (theme-adaptive)
EOF

  local basic_colors=(red green blue yellow cyan magenta orange pink)
  for color in "${basic_colors[@]}"; do
    local color_value
    color_value=$(format="hex" find_best_color_for_concept "$color")
    echo "\$$color: $color_value;" >>"$EWW_COLORS_FILE"
  done

  # Generate shell colors file
  cat >"$SHELL_COLORS_FILE" <<EOF
# Shell variables
# Generated by 'dots-smart-colors'

# Background and foreground variants
color_background='$background_color'
color_background_alt='$background_alt_color'
color_foreground='$foreground_color'
color_foreground_alt='$foreground_alt_color'

# Smart semantic colors
color_error='$error_color'
color_warning='$warning_color'
color_success='$success_color'
color_info='$info_color'
color_accent='$accent_color'

# Smart basic colors
EOF

  for color in "${basic_colors[@]}"; do
    local color_value
    color_value=$(format="hex" find_best_color_for_concept "$color")
    echo "color_${color}='$color_value'" >>"$SHELL_COLORS_FILE"
  done

  # Generate environment colors file
  cat >"$ENV_COLORS_FILE" <<EOF
# Environment variables for smart colors
# Generated by 'dots-smart-colors'
# Source this file: source $ENV_COLORS_FILE

# Background and foreground variants
export COLOR_BACKGROUND='$background_color'
export COLOR_BACKGROUND_ALT='$background_alt_color'
export COLOR_FOREGROUND='$foreground_color'
export COLOR_FOREGROUND_ALT='$foreground_alt_color'

# Smart semantic colors
export COLOR_ERROR='$error_color'
export COLOR_WARNING='$warning_color'
export COLOR_SUCCESS='$success_color'
export COLOR_INFO='$info_color'
export COLOR_ACCENT='$accent_color'

# Smart basic colors
EOF

  local extended_colors=(red green blue yellow cyan magenta orange pink brown white black gray)
  for color in "${extended_colors[@]}"; do
    local color_value
    color_value=$(format="hex" find_best_color_for_concept "$color")
    echo "export COLOR_${color^^}='$color_value'" >>"$ENV_COLORS_FILE"
  done

  # Get all smart basic colors
  local red_color
  red_color=$(format="hex" find_best_color_for_concept "red")
  local green_color
  green_color=$(format="hex" find_best_color_for_concept "green")
  local blue_color
  blue_color=$(format="hex" find_best_color_for_concept "blue")
  local yellow_color
  yellow_color=$(format="hex" find_best_color_for_concept "yellow")
  local cyan_color
  cyan_color=$(format="hex" find_best_color_for_concept "cyan")
  local magenta_color
  magenta_color=$(format="hex" find_best_color_for_concept "magenta")
  local orange_color
  orange_color=$(format="hex" find_best_color_for_concept "orange")
  local pink_color
  pink_color=$(format="hex" find_best_color_for_concept "pink")
  local white_color
  white_color=$(format="hex" find_best_color_for_concept "white")
  local black_color
  black_color=$(format="hex" find_best_color_for_concept "black")
  local gray_color
  gray_color=$(format="hex" find_best_color_for_concept "gray")

  # Generate Waybar CSS colors file
  local WAYBAR_COLORS_FILE="${SMART_COLORS_DIR}/colors-waybar.css"
  cat >"$WAYBAR_COLORS_FILE" <<EOF
/* Waybar colors configuration */
/* Generated by 'dots-smart-colors' */
/* Theme-adaptive colors for Wayland/Hyprland */

@define-color bg-primary $background_color;
@define-color bg-secondary ${base_colors[1]};
@define-color bg-hover ${base_colors[8]};
@define-color fg-primary $foreground_color;
@define-color fg-secondary ${base_colors[5]};

/* Smart semantic colors */
@define-color smart-error $error_color;
@define-color smart-warning $warning_color;
@define-color smart-success $success_color;
@define-color smart-info $info_color;
@define-color smart-accent $accent_color;

/* Smart basic colors */
@define-color smart-red $red_color;
@define-color smart-green $green_color;
@define-color smart-blue $blue_color;
@define-color smart-yellow $yellow_color;
@define-color smart-cyan $cyan_color;
@define-color smart-magenta $magenta_color;
@define-color smart-orange $orange_color;
@define-color smart-pink $pink_color;

/* Accent colors (for compatibility) */
@define-color accent-primary $accent_color;
@define-color accent-success $success_color;
@define-color accent-warning $warning_color;
@define-color accent-error $error_color;
@define-color accent-info $info_color;

/* Border colors */
@define-color border-color ${base_colors[8]};
EOF

  # Generate Mako config snippet
  local MAKO_COLORS_FILE="${SMART_COLORS_DIR}/colors-mako.conf"
  cat >"$MAKO_COLORS_FILE" <<EOF
# Mako notification colors
# Generated by 'dots-smart-colors'
# Include this in your mako config or replace values manually

background-color=$background_color
text-color=$foreground_color
border-color=$accent_color
progress-color=over ${base_colors[8]}

[urgency=low]
border-color=$info_color

[urgency=normal]
border-color=$accent_color

[urgency=critical]
border-color=$error_color
text-color=$error_color
EOF

  # Generate Hyprland colors config
  local HYPRLAND_COLORS_FILE="${SMART_COLORS_DIR}/colors-hyprland.conf"
  cat >"$HYPRLAND_COLORS_FILE" <<EOF
# Hyprland colors configuration
# Generated by 'dots-smart-colors'
# Source this in your hyprland.conf.d/colors.conf

general {
    col.active_border = rgba(${accent_color#\#}ee) rgba(${info_color#\#}ee) 45deg
    col.inactive_border = rgba(${base_colors[8]#\#}aa)
}

group {
    col.border_active = rgba(${accent_color#\#}ee)
    col.border_inactive = rgba(${base_colors[8]#\#}aa)
    col.border_locked_active = rgba(${warning_color#\#}ee)
    col.border_locked_inactive = rgba(${base_colors[8]#\#}aa)

    groupbar {
        col.active = rgba(${accent_color#\#}ee)
        col.inactive = rgba(${base_colors[8]#\#}aa)
        col.locked_active = rgba(${warning_color#\#}ee)
        col.locked_inactive = rgba(${base_colors[8]#\#}aa)
    }
}
EOF

  # Generate Wlogout CSS colors file
  local WLOGOUT_COLORS_FILE="${SMART_COLORS_DIR}/colors-wlogout.css"
  cat >"$WLOGOUT_COLORS_FILE" <<EOF
/* Wlogout colors configuration */
/* Generated by 'dots-smart-colors' */
/* Theme-adaptive colors for power menu */

@define-color wlogout-bg $background_color;
@define-color wlogout-fg $foreground_color;
@define-color wlogout-border $accent_color;

@define-color wlogout-bg-hover ${base_colors[8]};
@define-color wlogout-border-hover ${base_colors[13]};

@define-color wlogout-lock-bg ${base_colors[8]};
@define-color wlogout-logout-bg ${base_colors[8]};
@define-color wlogout-suspend-bg ${base_colors[8]};
@define-color wlogout-hibernate-bg ${base_colors[8]};
@define-color wlogout-shutdown-bg ${base_colors[8]};
@define-color wlogout-reboot-bg ${base_colors[8]};

@define-color smart-color-error $error_color;
@define-color smart-color-warning $warning_color;
@define-color smart-color-success $success_color;
@define-color smart-color-info $info_color;
@define-color smart-color-accent $accent_color;
@define-color smart-color-highlight ${base_colors[13]};
@define-color smart-color-muted ${base_colors[6]};

@define-color wlogout-focus-ring ${base_colors[8]};
EOF

  # Generate CopyQ theme file (.ini format)
  local COPYQ_THEME_FILE="${SMART_COLORS_DIR}/colors-copyq.ini"
  local COPYQ_CONFIG_DIR="${HOME}/.config/copyq"
  local COPYQ_THEMES_DIR="${COPYQ_CONFIG_DIR}/themes"
  
  # Create themes directory if it doesn't exist
  mkdir -p "$COPYQ_THEMES_DIR"
  
  # Detect if theme is light or dark based on background luminance
  local bg_luminance
  bg_luminance=$(calculate_luminance "$background_color")
  
  # Determine if light or dark theme (threshold: 128)
  local is_light_theme=false
  if [[ $bg_luminance -gt 128 ]]; then
    is_light_theme=true
  fi
  
  # Adjust colors based on theme type for better balance
  local base_bg base_fg base_alt_bg base_sel_bg base_sel_fg
  if [[ $is_light_theme == true ]]; then
    # Light theme: use softer, lighter colors with subtle variations
    base_bg="$background_color"
    base_fg="$foreground_color"
    base_alt_bg="bg - #0a0a0a"  # More subtle difference
    base_sel_bg="$accent_color"
    # Ensure good contrast for selection text
    base_sel_fg="$background_color"
  else
    # Dark theme: use brighter, more contrasted colors but not too bright
    base_bg="$background_color"
    base_fg="$foreground_color"
    base_alt_bg="bg + #1a1a1a"  # More subtle difference for dark theme
    base_sel_bg="$accent_color"
    # Use foreground for better contrast in dark themes
    base_sel_fg="$foreground_color"
  fi
  
  # Generate theme .ini file with smart-colors placeholders
  cat >"$COPYQ_THEME_FILE" <<EOF
[General]
# CopyQ Theme - Smart Colors Integration
# Generated by 'dots-smart-colors'
# Colors are theme-adaptive and follow HorneroConfig design principles
# Theme type: $([ "$is_light_theme" = true ] && echo "light" || echo "dark")

# Fonts
font="JetBrainsMono Nerd Font,10,-1,5,50,0,0,0,0,0"
edit_font="JetBrainsMono Nerd Font,11,-1,5,50,0,0,0,0,0"
find_font="JetBrainsMono Nerd Font,10,-1,5,50,0,0,0,0,0"
notes_font="JetBrainsMono Nerd Font,11,-1,5,50,0,0,0,0,0"
num_font="JetBrainsMono Nerd Font,7,-1,5,25,0,0,0,0,0"
font_antialiasing=true

# Main colors - balanced and readable
bg=$base_bg
fg=$base_fg
alt_bg=$base_alt_bg
alt_fg=fg $([ "$is_light_theme" = true ] && echo "- #1a1a1a" || echo "+ #1a1a1a")

# Selection colors - use accent color with good contrast
sel_bg=$base_sel_bg
sel_fg=$base_sel_fg

# Editor colors - subtle difference from main bg for better UX
edit_bg=$([ "$is_light_theme" = true ] && echo "bg - #0a0a0a" || echo "bg + #0a0a0a")
edit_fg=fg $([ "$is_light_theme" = true ] && echo "- #0a0a0a" || echo "+ #0a0a0a")

# Find/search colors - use accent for visibility but not overwhelming
find_bg="rgba(0,0,0,0)"
find_fg=$accent_color

# Notes colors - readable but distinct
notes_bg=bg
notes_fg=fg $([ "$is_light_theme" = true ] && echo "- #2a2a2a" || echo "+ #2a2a2a")

# Number colors - use info color but adjust for theme
num_fg=$info_color $([ "$is_light_theme" = true ] && echo "+ #111" || echo "- #111")

# Show options
show_scrollbars=false
show_number=true
style_main_window=true
use_system_icons=false

# Item styling
item_css=padding:0.5em
alt_item_css=

# Selection item styling with gradient
sel_item_css="
    ;background: qlineargradient(
        x1: 0, y1: 0,
        x2: 1, y2: 0,
        stop: 0 \${sel_bg},
        stop: 1 \${sel_bg} + #111
        )"

# Search bar styling
search_bar="
    ;background: \${edit_bg}
    ;color: \${edit_fg}
    ;border: 1px solid \${alt_bg}
    ;margin: 2px
    ;border-radius: 4px"

search_bar_focused="
    ;border: 1px solid \${sel_bg}"

# Tab bar styling - balanced contrast
tab_bar_css="
    ;background: \${bg} $([ "$is_light_theme" = true ] && echo "- #1a1a1a" || echo "+ #1a1a1a")"

tab_bar_tab_selected_css="
    ;padding: 0.5em
    ;background: \${bg}
    ;border: 0.05em solid \${bg}
    ;color: \${fg}
    ;border-bottom: 2px solid \${sel_bg}"

tab_bar_tab_unselected_css="
    ;border: 0.05em solid \${bg}
    ;padding: 0.5em
    ;background: \${bg} $([ "$is_light_theme" = true ] && echo "- #1a1a1a" || echo "+ #1a1a1a")
    ;color: \${fg} $([ "$is_light_theme" = true ] && echo "- #2a2a2a" || echo "+ #2a2a2a")"

tab_bar_item_counter="
    ;color: \${num_fg} $([ "$is_light_theme" = true ] && echo "+ #1a1a1a" || echo "- #1a1a1a")
    ;font-size: 7pt"

tab_bar_sel_item_counter="
    ;color: \${num_fg}"

tab_bar_scroll_buttons_css="
    ;background: \${bg} $([ "$is_light_theme" = true ] && echo "- #1a1a1a" || echo "+ #1a1a1a")
    ;color: \${fg}
    ;border: 0"

# Tab tree styling - improved readability
tab_tree_css="
    ;font-family: sans-serif
    ;font-size: 10pt
    ;padding: .20em
    ;color: \${fg} $([ "$is_light_theme" = true ] && echo "+ #1a1a1a" || echo "- #1a1a1a")
    ;background-color: \${bg}"

tab_tree_sel_item_css="
    ;color: \${fg} $([ "$is_light_theme" = true ] && echo "+ #1a1a1a" || echo "- #1a1a1a")
    ;background: \${bg} $([ "$is_light_theme" = true ] && echo "- #0f0f0f" || echo "+ #0f0f0f")"

tab_tree_item_counter="
    ;padding:.33em
    ;color: \${num_fg} $([ "$is_light_theme" = true ] && echo "+ #1a1a1a" || echo "- #1a1a1a")
    ;font-size: 7pt"

tab_tree_sel_item_counter="
    ;color: \${num_fg}"

# Toolbar styling - subtle and balanced
tool_bar_css="
    ;color: \${fg}
    ;background-color: \${bg}
    ;border: 0"

tool_button_css="
    ;background-color: transparent"

tool_button_selected_css="
    ;background-color: \${bg} $([ "$is_light_theme" = true ] && echo "- #0a0a0a" || echo "+ #0a0a0a")"

tool_button_pressed_css="
    ;background-color: \${sel_bg}
    ;color: \${sel_fg}"

# Menu bar styling - balanced contrast
menu_bar_css="
    ;background: \${bg}
    ;color: \${fg} $([ "$is_light_theme" = true ] && echo "+ #2a2a2a" || echo "- #2a2a2a")"

menu_bar_disabled_css="
    ;color: \${bg} $([ "$is_light_theme" = true ] && echo "- #4a4a4a" || echo "+ #4a4a4a")"

menu_bar_selected_css="
    ;background: \${sel_bg}
    ;color: \${sel_fg}"

menu_css="
    ;border-top: 0.08em solid \${bg} $([ "$is_light_theme" = true ] && echo "+ #2a2a2a" || echo "- #2a2a2a")
    ;border-left: 0.08em solid \${bg} $([ "$is_light_theme" = true ] && echo "+ #2a2a2a" || echo "- #2a2a2a")
    ;border-bottom: 0.08em solid \${bg} $([ "$is_light_theme" = true ] && echo "- #2a2a2a" || echo "+ #2a2a2a")
    ;border-right: 0.08em solid \${bg} $([ "$is_light_theme" = true ] && echo "- #2a2a2a" || echo "+ #2a2a2a")"

# Additional CSS customizations - subtle hover effects
css="
    ClipboardBrowser::item{
        border-bottom: 1px solid \${alt_bg}
    }
    ClipboardBrowser::item:hover{
        background: \${bg} $([ "$is_light_theme" = true ] && echo "- #0a0a0a" || echo "+ #0a0a0a")
    }"

notes_css=
EOF

  # Create symlink to theme file in copyq themes directory
  local copyq_theme_link="${COPYQ_THEMES_DIR}/hornero-smart-colors.ini"
  if [[ ! -L "$copyq_theme_link" ]] || [[ "$(readlink -f "$copyq_theme_link" 2>/dev/null)" != "$(readlink -f "$COPYQ_THEME_FILE" 2>/dev/null)" ]]; then
    ln -sf "$COPYQ_THEME_FILE" "$copyq_theme_link" 2>/dev/null || true
  fi

  # Generate Hyprlock colors file (for dots-lockscreen integration)
  local HYPRLOCK_COLORS_FILE="${SMART_COLORS_DIR}/colors-hyprlock.env"
  cat >"$HYPRLOCK_COLORS_FILE" <<EOF
# Hyprlock colors configuration
# Generated by 'dots-smart-colors'
# Source this in dots-lockscreen for theme-adaptive lock screens

# Background and foreground (without # prefix for hyprlock rgba)
SMART_BG="$background_color"
SMART_FG="$foreground_color"
SMART_BG_HEX="${background_color#\#}"
SMART_FG_HEX="${foreground_color#\#}"

# Primary and accent colors
SMART_PRIMARY="$accent_color"
SMART_PRIMARY_HEX="${accent_color#\#}"
SMART_ACCENT="$accent_color"
SMART_ACCENT_HEX="${accent_color#\#}"

# Semantic colors
SMART_ERROR="$error_color"
SMART_ERROR_HEX="${error_color#\#}"
SMART_WARNING="$warning_color"
SMART_WARNING_HEX="${warning_color#\#}"
SMART_SUCCESS="$success_color"
SMART_SUCCESS_HEX="${success_color#\#}"
SMART_INFO="$info_color"
SMART_INFO_HEX="${info_color#\#}"

# Basic colors
SMART_RED="$red_color"
SMART_GREEN="$green_color"
SMART_BLUE="$blue_color"
SMART_YELLOW="$yellow_color"
SMART_CYAN="$cyan_color"
SMART_MAGENTA="$magenta_color"
SMART_ORANGE="$orange_color"
SMART_PINK="$pink_color"

# Theme type
SMART_THEME_TYPE="$(is_light_theme && echo "light" || echo "dark")"
EOF

  # Generate Rofi colors file (.rasi format)
  local ROFI_COLORS_FILE="${SMART_COLORS_DIR}/colors-rofi.rasi"
  cat >"$ROFI_COLORS_FILE" <<EOF
/* Rofi colors configuration */
/* Generated by 'dots-smart-colors' */
/* @import this file in your rofi theme for theme-adaptive colors */

* {
    /* Background colors */
    smart-bg:           $background_color;
    smart-bg-alt:       $background_alt_color;
    smart-fg:           $foreground_color;
    smart-fg-alt:       $foreground_alt_color;
    
    /* Semantic colors */
    smart-error:        $error_color;
    smart-warning:      $warning_color;
    smart-success:      $success_color;
    smart-info:         $info_color;
    smart-accent:       $accent_color;
    
    /* Basic colors */
    smart-red:          $red_color;
    smart-green:        $green_color;
    smart-blue:         $blue_color;
    smart-yellow:       $yellow_color;
    smart-cyan:         $cyan_color;
    smart-magenta:      $magenta_color;
    smart-orange:       $orange_color;
    smart-pink:         $pink_color;
    
    /* Computed colors for common use cases */
    smart-selected-bg:  $accent_color;
    smart-selected-fg:  $background_color;
    smart-urgent-bg:    $error_color;
    smart-urgent-fg:    $foreground_color;
    smart-active-bg:    $success_color;
    smart-active-fg:    $background_color;
    
    /* Border and separator colors */
    smart-border:       ${base_colors[8]};
    smart-separator:    ${base_colors[8]};
}
EOF

  # Generate Kitty colors file
  local KITTY_COLORS_FILE="${SMART_COLORS_DIR}/colors-kitty.conf"
  cat >"$KITTY_COLORS_FILE" <<EOF
# Kitty terminal colors
# Generated by 'dots-smart-colors'
# Include this in kitty.conf: include ~/.cache/dots/smart-colors/colors-kitty.conf

# Base colors
background $background_color
foreground $foreground_color
cursor $cursor_color
selection_background $accent_color
selection_foreground $background_color

# Black
color0 ${base_colors[0]}
color8 ${base_colors[8]}

# Red
color1 ${base_colors[1]}
color9 ${base_colors[9]}

# Green
color2 ${base_colors[2]}
color10 ${base_colors[10]}

# Yellow
color3 ${base_colors[3]}
color11 ${base_colors[11]}

# Blue
color4 ${base_colors[4]}
color12 ${base_colors[12]}

# Magenta
color5 ${base_colors[5]}
color13 ${base_colors[13]}

# Cyan
color6 ${base_colors[6]}
color14 ${base_colors[14]}

# White
color7 ${base_colors[7]}
color15 ${base_colors[15]}
EOF

  # Generate CSS variables file (generic, for any CSS-based app)
  local CSS_VARS_FILE="${SMART_COLORS_DIR}/colors.css"
  cat >"$CSS_VARS_FILE" <<EOF
/* CSS Custom Properties for Smart Colors */
/* Generated by 'dots-smart-colors' */
/* Include this in any CSS file: @import url('~/.cache/dots/smart-colors/colors.css'); */

:root {
    /* Background and foreground */
    --smart-bg: $background_color;
    --smart-bg-alt: $background_alt_color;
    --smart-fg: $foreground_color;
    --smart-fg-alt: $foreground_alt_color;
    
    /* Semantic colors */
    --smart-error: $error_color;
    --smart-warning: $warning_color;
    --smart-success: $success_color;
    --smart-info: $info_color;
    --smart-accent: $accent_color;
    
    /* Basic colors */
    --smart-red: $red_color;
    --smart-green: $green_color;
    --smart-blue: $blue_color;
    --smart-yellow: $yellow_color;
    --smart-cyan: $cyan_color;
    --smart-magenta: $magenta_color;
    --smart-orange: $orange_color;
    --smart-pink: $pink_color;
    
    /* Base16 colors */
    --color0: ${base_colors[0]};
    --color1: ${base_colors[1]};
    --color2: ${base_colors[2]};
    --color3: ${base_colors[3]};
    --color4: ${base_colors[4]};
    --color5: ${base_colors[5]};
    --color6: ${base_colors[6]};
    --color7: ${base_colors[7]};
    --color8: ${base_colors[8]};
    --color9: ${base_colors[9]};
    --color10: ${base_colors[10]};
    --color11: ${base_colors[11]};
    --color12: ${base_colors[12]};
    --color13: ${base_colors[13]};
    --color14: ${base_colors[14]};
    --color15: ${base_colors[15]};
}
EOF

  # Create current.env symlink for easy sourcing (used by dots-lockscreen)
  local CURRENT_ENV_FILE="${SMART_COLORS_DIR}/current.env"
  cp "$HYPRLOCK_COLORS_FILE" "$CURRENT_ENV_FILE"

  show_success "Smart color files generated in $SMART_COLORS_DIR"
  show_info "Generated: EWW, Waybar, Mako, Hyprland, Hyprlock, Wlogout, CopyQ, Rofi, Kitty, CSS"
}

# Main script logic
main() {
  # Check dependencies
  command -v xrdb >/dev/null 2>&1 || {
    show_error "xrdb not found"
    exit 1
  }

  # Handle options
  if [[ -n $analyze ]]; then
    show_palette_visual
  elif [[ -n $colors ]]; then
    show_palette_visual
  elif [[ -n $export ]]; then
    case "${format:-shell}" in
      files) generate_smart_color_files ;;
      *)
        local concepts=(error warning success info accent red green blue yellow cyan magenta orange pink brown white black gray)
        echo "# Smart color variables generated by dots-smart-colors"
        echo "# Source this file or copy to your shell configuration"
        echo

        echo "# Background and foreground variants"
        for concept in background background-alt foreground foreground-alt; do
          local color
          color=$(find_best_color_for_concept "$concept")
          echo "export COLOR_${concept^^//-/_}='$color'"
        done

        echo
        echo "# Semantic colors"
        for concept in error warning success info accent; do
          local color
          color=$(find_best_color_for_concept "$concept")
          echo "export COLOR_${concept^^}='$color'"
        done

        echo
        echo "# Basic colors"
        for concept in red green blue yellow cyan magenta orange pink brown white black gray; do
          local color
          color=$(find_best_color_for_concept "$concept")
          echo "export COLOR_${concept^^}='$color'"
        done

        ;;
    esac
  elif [[ -n ${concept:-} ]]; then
    find_best_color_for_concept "$concept"
  elif [[ -n ${generate:-} ]]; then
    generate_smart_color_files
  else
    # Default: show quick palette
    echo -e "${BOLD}Smart Colors Preview:${NC}"

    # Show background/foreground first
    local bg_fg_colors=(background foreground background-alt foreground-alt)
    for concept in "${bg_fg_colors[@]}"; do
      local color
      color=$(find_best_color_for_concept "$concept")
      show_color_block "$color" "$concept"
    done

    echo
    echo -e "${BOLD}Semantic Colors:${NC}"
    local concepts=(error warning success info accent)
    for concept in "${concepts[@]}"; do
      local color
      color=$(find_best_color_for_concept "$concept")
      show_color_block "$color" "$concept"
    done
    echo
    show_info "Use --help for more options"
  fi
}

# Run main function
main "$@"
