#!/usr/bin/env bash

## Copyright (C) 2019-2025 Ulises Jeremias Cornejo Fandos
## Licensed under MIT.
##
## Smart color palette analyzer and theme-adaptive color selector
## Analyzes your current X resources color palette and suggests the best colors
## for different semantic concepts (error, warning, success, info, etc.)
##
## Usage:
##     @script.name [OPTION] ARGUMENTS...
##
## Options:
##     -h, --help                            Show this help message.
##     -a, --analyze                         Analyze current palette and show recommendations.
##     -c, --colors                          Show visual color palette with blocks.
##     -e, --export                          Export color variables for shell/polybar.
##         --concept=CONCEPT                 Get best color for specific concept (error|warning|success|info|accent|red|green|blue|yellow|cyan|magenta|orange|pink|brown|white|black|gray).
##         --format=FORMAT                   Output format: hex, rgb, polybar, eww, scss, i3, files (default: hex).
##         --generate                        Generate all smart color files in ~/.cache/dots/smart-colors/.
##     -v, --verbose                         Show detailed analysis.

source ~/.local/lib/dots/easy-options/easyoptions.sh || exit 1

# Output colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# File paths
readonly CACHE_DIR="${HOME}/.cache/dots"
readonly SMART_COLORS_DIR="${CACHE_DIR}/smart-colors"
readonly I3_COLORS_FILE="${SMART_COLORS_DIR}/colors-i3.conf"
readonly EWW_COLORS_FILE="${SMART_COLORS_DIR}/colors-eww.scss"
readonly SHELL_COLORS_FILE="${SMART_COLORS_DIR}/colors.sh"
readonly ENV_COLORS_FILE="${SMART_COLORS_DIR}/colors.env"

# Status functions
show_status() { echo -e "${CYAN}🎨${NC} $1"; }
show_success() { echo -e "${GREEN}✅${NC} $1"; }
show_error() { echo -e "${RED}❌${NC} $1"; }
show_info() { echo -e "${BLUE}ℹ️${NC} $1"; }

# Convert hex to RGB values
hex_to_rgb() {
    local hex="${1#\#}"
    echo $((16#${hex:0:2})) $((16#${hex:2:2})) $((16#${hex:4:2}))
}

# Convert hex to ANSI background color for terminal display
hex_to_ansi_bg() {
    local rgb; rgb=$(hex_to_rgb "$1")
    echo "\033[48;2;${rgb// /;}m"
}

# Show color block in terminal
show_color_block() {
    local hex="$1" label="$2" width="${3:-8}"
    local ansi_bg; ansi_bg=$(hex_to_ansi_bg "$hex")
    local spaces; printf -v spaces "%*s" "$width" ""
    printf "${ansi_bg}${spaces}${NC} %-10s %s\n" "$label" "$hex"
}

# Detect palette's dominant color tendency
get_palette_dominant_color() {
    local brightest_color="" brightest_value=0

    # Check bright colors (9-14) for dominant hue
    for i in {9..14}; do
        local color; color=$(xrdb -get "color$i" 2>/dev/null) || continue
        local hex="${color#\#}"
        local r=$((16#${hex:0:2})) g=$((16#${hex:2:2})) b=$((16#${hex:4:2}))
        local brightness=$((r + g + b))

        if [[ $brightness -gt $brightest_value ]]; then
            brightest_value=$brightness
            brightest_color="$color"
        fi
    done

    # Classify hue based on RGB dominance
    if [[ -n "$brightest_color" ]]; then
        local hex="${brightest_color#\#}"
        local r=$((16#${hex:0:2})) g=$((16#${hex:2:2})) b=$((16#${hex:4:2}))

        if [[ $r -gt $g && $r -gt $b ]]; then
            [[ $g -gt 100 ]] && echo "orange" || [[ $b -gt 100 ]] && echo "purple" || echo "red"
        elif [[ $g -gt $r && $g -gt $b ]]; then
            [[ $r -gt 100 ]] && echo "yellow" || [[ $b -gt 100 ]] && echo "cyan" || echo "green"
        elif [[ $b -gt $r && $b -gt $g ]]; then
            [[ $r -gt 100 ]] && echo "purple" || [[ $g -gt 100 ]] && echo "cyan" || echo "blue"
        else
            echo "gray"
        fi
    else
        echo "unknown"
    fi
}

# Get palette average color for harmonization
get_palette_average() {
    local total_r=0 total_g=0 total_b=0 color_count=0

    for i in {1..14}; do
        local color; color=$(xrdb -get "color$i" 2>/dev/null) || continue
        local hex="${color#\#}"
        local r=$((16#${hex:0:2})) g=$((16#${hex:2:2})) b=$((16#${hex:4:2}))

        total_r=$((total_r + r))
        total_g=$((total_g + g))
        total_b=$((total_b + b))
        ((color_count++))
    done

    if [[ $color_count -gt 0 ]]; then
        local avg_r=$((total_r / color_count))
        local avg_g=$((total_g / color_count))
        local avg_b=$((total_b / color_count))
        printf "#%02x%02x%02x" "$avg_r" "$avg_g" "$avg_b"
    else
        echo "#808080"
    fi
}

# Blend two colors with specified percentage
blend_colors() {
    local color1="$1" color2="$2" blend_percent="$3"

    local hex1="${color1#\#}" hex2="${color2#\#}"
    local r1=$((16#${hex1:0:2})) g1=$((16#${hex1:2:2})) b1=$((16#${hex1:4:2}))
    local r2=$((16#${hex2:0:2})) g2=$((16#${hex2:2:2})) b2=$((16#${hex2:4:2}))

    local inv_percent=$((100 - blend_percent))
    local result_r=$(((r1 * inv_percent + r2 * blend_percent) / 100))
    local result_g=$(((g1 * inv_percent + g2 * blend_percent) / 100))
    local result_b=$(((b1 * inv_percent + b2 * blend_percent) / 100))

    # Clamp to 0-255
    [[ $result_r -gt 255 ]] && result_r=255 || [[ $result_r -lt 0 ]] && result_r=0
    [[ $result_g -gt 255 ]] && result_g=255 || [[ $result_g -lt 0 ]] && result_g=0
    [[ $result_b -gt 255 ]] && result_b=255 || [[ $result_b -lt 0 ]] && result_b=0

    printf "#%02x%02x%02x" "$result_r" "$result_g" "$result_b"
}

# CORE FUNCTION: Semantic color lookup table with palette adaptation
get_smart_color() {
    local concept="$1" palette_dominant="$2"

    # Handle neutrals separately (don't need palette adaptation)
    case "$concept" in
        white) xrdb -get "foreground" 2>/dev/null || echo "#ffffff"; return ;;
        black) xrdb -get "background" 2>/dev/null || echo "#000000"; return ;;
        gray|grey) xrdb -get "color8" 2>/dev/null || echo "#808080"; return ;;
    esac

    # Lookup table: concept|palette_tendency -> semantically correct color
    case "$concept|$palette_dominant" in
        # ERROR (always reddish)
        "error|red") echo "#ff4444" ;;
        "error|orange") echo "#ff3300" ;;
        "error|purple") echo "#ff4488" ;;
        "error|"*) echo "#cc4444" ;;

        # WARNING (always orange/yellow)
        "warning|orange") echo "#ff9900" ;;
        "warning|yellow") echo "#ffcc00" ;;
        "warning|red") echo "#ff6600" ;;
        "warning|"*) echo "#cc8800" ;;

        # SUCCESS (always greenish)
        "success|green") echo "#44aa44" ;;
        "success|cyan") echo "#00cc66" ;;
        "success|blue") echo "#0099aa" ;;
        "success|"*) echo "#669944" ;;

        # INFO (always bluish)
        "info|blue") echo "#4488ff" ;;
        "info|cyan") echo "#0099cc" ;;
        "info|purple") echo "#6666cc" ;;
        "info|"*) echo "#4488cc" ;;

        # ACCENT (distinctive highlight)
        "accent|purple") echo "#aa66ff" ;;
        "accent|pink") echo "#ff66aa" ;;
        "accent|orange") echo "#ff8833" ;;
        "accent|"*) echo "#8866aa" ;;

        # BASIC COLORS (maintain identity, different from semantic overlap)
        "red|red") echo "#ee3333" ;;
        "red|orange") echo "#ff2200" ;;
        "red|"*) echo "#bb3333" ;;

        "green|green") echo "#33aa33" ;;
        "green|cyan") echo "#00bb55" ;;
        "green|"*) echo "#558833" ;;

        "blue|blue") echo "#3377ee" ;;
        "blue|cyan") echo "#0088bb" ;;
        "blue|"*) echo "#3377bb" ;;

        "yellow|yellow") echo "#ffdd00" ;;
        "yellow|orange") echo "#ffcc00" ;;
        "yellow|"*) echo "#bbbb33" ;;

        "cyan|cyan") echo "#00dddd" ;;
        "cyan|blue") echo "#0099cc" ;;
        "cyan|"*) echo "#4499aa" ;;

        "magenta|purple"|"purple|purple") echo "#dd44dd" ;;
        "magenta|pink"|"purple|pink") echo "#ff66cc" ;;
        "magenta|"*|"purple|"*) echo "#bb55aa" ;;

        "orange|orange") echo "#ff7700" ;;
        "orange|red") echo "#ff5500" ;;
        "orange|"*) echo "#bb7700" ;;

        "pink|pink") echo "#ff88cc" ;;
        "pink|purple") echo "#ff66aa" ;;
        "pink|"*) echo "#dd99bb" ;;

        "brown|red") echo "#aa4422" ;;
        "brown|orange") echo "#cc6633" ;;
        "brown|"*) echo "#996633" ;;

        # FALLBACKS
        *) echo "#888888" ;;
    esac
}

# Main function: Find best color for concept
find_best_color_for_concept() {
    local concept="$1"

    # Validate concept
    case "$concept" in
        error|warning|success|info|accent|red|green|blue|yellow|cyan|magenta|purple|orange|pink|brown|white|black|gray|grey) ;;
        *)
            show_error "Unknown concept: $concept"
            return 1
            ;;
    esac

    # Handle neutrals directly
    case "$concept" in
        white|black|gray|grey)
            get_smart_color "$concept"
            return 0
            ;;
    esac

    # Get palette characteristics
    local dominant_color; dominant_color=$(get_palette_dominant_color)
    local palette_average; palette_average=$(get_palette_average)

    # Get base semantic color
    local base_color; base_color=$(get_smart_color "$concept" "$dominant_color")

    # Harmonize with palette (subtle 15% blend)
    local final_color; final_color=$(blend_colors "$base_color" "$palette_average" 15)

    # Format output
    case "${format:-hex}" in
        hex) echo "$final_color" ;;
        rgb) hex_to_rgb "$final_color" ;;
        *) echo "$final_color" ;;
    esac
}

# Show visual palette
show_palette_visual() {
    echo -e "${BOLD}Current Palette:${NC}"

    # Base16 colors
    for i in {0..15}; do
        local color; color=$(xrdb -get "color$i" 2>/dev/null) || continue
        show_color_block "$color" "color$i"
    done

    echo
    echo -e "${BOLD}Smart Semantic Colors:${NC}"
    local concepts=(error warning success info accent)
    for concept in "${concepts[@]}"; do
        local color; color=$(find_best_color_for_concept "$concept")
        show_color_block "$color" "$concept"
    done

    echo
    echo -e "${BOLD}Smart Basic Colors:${NC}"
    local basic_colors=(red green blue yellow cyan magenta orange pink)
    for color in "${basic_colors[@]}"; do
        local color_value; color_value=$(find_best_color_for_concept "$color")
        show_color_block "$color_value" "$color"
    done

    echo
}

# Generate file outputs
generate_smart_color_files() {
    show_status "Generating smart color files..."
    mkdir -p "$SMART_COLORS_DIR"

    # Generate smart colors
    local error_color; error_color=$(format="hex" find_best_color_for_concept "error")
    local warning_color; warning_color=$(format="hex" find_best_color_for_concept "warning")
    local success_color; success_color=$(format="hex" find_best_color_for_concept "success")
    local info_color; info_color=$(format="hex" find_best_color_for_concept "info")
    local accent_color; accent_color=$(format="hex" find_best_color_for_concept "accent")

    # Get palette colors
    local bg; bg=$(xrdb -get "background" 2>/dev/null || echo "#000000")
    local fg; fg=$(xrdb -get "foreground" 2>/dev/null || echo "#ffffff")
    local cursor; cursor=$(xrdb -get "cursor" 2>/dev/null || echo "$fg")
    local base_colors=()
    for i in {0..15}; do
        base_colors[i]=$(xrdb -get "color$i" 2>/dev/null || echo "#000000")
    done

    # Get wallpaper path
    local wallpaper_path=""
    if [[ -f ~/.cache/wal/wal ]]; then
        wallpaper_path=$(cat ~/.cache/wal/wal)
    elif [[ -f ~/.config/wpg/wp_init.py ]]; then
        wallpaper_path=$(python3 -c "import os; exec(open(os.path.expanduser('~/.config/wpg/wp_init.py')).read()); print(wallpaper)" 2>/dev/null || echo "")
    fi
    [[ -z "$wallpaper_path" ]] && wallpaper_path="/home/$(whoami)/.wallpaper"

    # Generate i3 colors file
    cat > "$I3_COLORS_FILE" << EOF
# Color palette generated by dots-smart-colors
# Based on current X resources and smart color analysis
# Auto-generated - do not edit manually
#
# NOTE: Values are direct color codes (not variables) because i3 cannot
# expand variables defined in included files

# Enhanced i3 color scheme using Base16 + Smart Colors
# Property Name         Border          BG              Text        Indicator       Child Border
client.focused          $accent_color  $accent_color  ${base_colors[0]}  $info_color    $accent_color
client.focused_inactive ${base_colors[1]} ${base_colors[1]} ${base_colors[5]} ${base_colors[1]} ${base_colors[1]}
client.unfocused        ${base_colors[1]} $bg ${base_colors[5]} ${base_colors[1]} ${base_colors[1]}
client.urgent           $error_color   $error_color   ${base_colors[0]} $error_color   $error_color
client.placeholder      $bg            $bg            ${base_colors[5]} $bg            $bg
client.background       ${base_colors[7]}

# Smart color reference (for documentation)
# error=$error_color
# warning=$warning_color
# success=$success_color
# info=$info_color
# accent=$accent_color
EOF

    # Generate EWW colors file
    cat > "$EWW_COLORS_FILE" << EOF
// SCSS Variables
// Generated by 'dots-smart-colors'
\$wallpaper: "$wallpaper_path";

// Special
\$background: $bg;
\$foreground: $fg;
\$cursor: $cursor;

// Colors
EOF

    for i in {0..15}; do
        echo "\$color$i: ${base_colors[i]};" >> "$EWW_COLORS_FILE"
    done

    cat >> "$EWW_COLORS_FILE" << EOF

// Smart semantic colors (theme-adaptive)
\$smart-error: $error_color;
\$smart-warning: $warning_color;
\$smart-success: $success_color;
\$smart-info: $info_color;
\$smart-accent: $accent_color;

// Smart basic colors (theme-adaptive)
EOF

    local basic_colors=(red green blue yellow cyan magenta orange pink)
    for color in "${basic_colors[@]}"; do
        local color_value; color_value=$(format="hex" find_best_color_for_concept "$color")
        echo "\$smart-$color: $color_value;" >> "$EWW_COLORS_FILE"
    done

    # Generate shell colors file
    cat > "$SHELL_COLORS_FILE" << EOF
# Shell variables
# Generated by 'dots-smart-colors'

# Smart semantic colors
smart_color_error='$error_color'
smart_color_warning='$warning_color'
smart_color_success='$success_color'
smart_color_info='$info_color'
smart_color_accent='$accent_color'

# Smart basic colors
EOF

    for color in "${basic_colors[@]}"; do
        local color_value; color_value=$(format="hex" find_best_color_for_concept "$color")
        echo "smart_color_${color}='$color_value'" >> "$SHELL_COLORS_FILE"
    done

    # Generate environment colors file
    cat > "$ENV_COLORS_FILE" << EOF
# Environment variables for smart colors
# Generated by 'dots-smart-colors'
# Source this file: source $ENV_COLORS_FILE

# Smart semantic colors
export SMART_COLOR_ERROR='$error_color'
export SMART_COLOR_WARNING='$warning_color'
export SMART_COLOR_SUCCESS='$success_color'
export SMART_COLOR_INFO='$info_color'
export SMART_COLOR_ACCENT='$accent_color'

# Smart basic colors
EOF

    local extended_colors=(red green blue yellow cyan magenta orange pink brown white black gray)
    for color in "${extended_colors[@]}"; do
        local color_value; color_value=$(format="hex" find_best_color_for_concept "$color")
        echo "export SMART_COLOR_${color^^}='$color_value'" >> "$ENV_COLORS_FILE"
    done

    show_success "Smart color files generated in $SMART_COLORS_DIR"
}

# Main script logic
main() {
    # Check dependencies
    command -v xrdb >/dev/null 2>&1 || { show_error "xrdb not found"; exit 1; }

    # Handle options
    if [[ -n "$analyze" ]]; then
        show_palette_visual
    elif [[ -n "$colors" ]]; then
        show_palette_visual
    elif [[ -n "$export" ]]; then
        case "${format:-shell}" in
            files) generate_smart_color_files ;;
            *)
                local concepts=(error warning success info accent red green blue yellow cyan magenta orange pink brown white black gray)
                echo "# Smart color variables generated by dots-smart-colors"
                echo "# Source this file or copy to your shell/polybar config"
                echo

                echo "# Semantic colors"
                for concept in error warning success info accent; do
                    local color; color=$(find_best_color_for_concept "$concept")
                    echo "export SMART_COLOR_${concept^^}='$color'"
                done

                echo
                echo "# Basic colors"
                for concept in red green blue yellow cyan magenta orange pink brown white black gray; do
                    local color; color=$(find_best_color_for_concept "$concept")
                    echo "export SMART_COLOR_${concept^^}='$color'"
                done

                echo
                echo "# Polybar format variables (semantic)"
                for concept in error warning success info accent; do
                    local color; color=$(format="polybar" find_best_color_for_concept "$concept")
                    echo "# smart-$concept = $color"
                done

                echo
                echo "# Polybar format variables (basic colors)"
                for concept in red green blue yellow cyan magenta orange pink; do
                    local color; color=$(format="polybar" find_best_color_for_concept "$concept")
                    echo "# smart-$concept = $color"
                done
                ;;
        esac
    elif [[ -n "$concept" ]]; then
        find_best_color_for_concept "$concept"
    elif [[ -n "$generate" ]]; then
        generate_smart_color_files
    else
        # Default: show quick palette
        echo -e "${BOLD}Smart Colors Preview:${NC}"
        local concepts=(error warning success info accent)
        for concept in "${concepts[@]}"; do
            local color; color=$(find_best_color_for_concept "$concept")
            show_color_block "$color" "$concept"
        done
        echo
        show_info "Use --help for more options"
    fi
}

# Run main function
main "$@"
