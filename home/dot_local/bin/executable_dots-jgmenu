#!/usr/bin/env bash

## Copyright (C) 2019-2025 Ulises Jeremias Cornejo Fandos
## Licensed under MIT.
##
## Launch jgmenu with smart color integration and configurable positioning
##
## Check full documentation at: https://github.com/ulises-jeremias/dotfiles/wiki
##
## Usage:
##     @script.name [OPTIONS]
##
## Options:
##     -h, --help              Show this help message
##     -v, --verbose           Enable verbose output
##         --config=PATH       Use specific config file (default: ~/.config/jgmenu/jgmenurc-config)
##     -x, --position-x=NUM    X coordinate for menu (default: auto-detect from bar position)
##     -y, --position-y=NUM    Y coordinate for menu (default: auto-detect from bar position)
##         --position-mode=MODE Position mode: pointer, fixed, center, ipc (default: auto-detect)
##         --halign=ALIGN      Horizontal alignment: left, center, right (default: left)
##         --valign=ALIGN      Vertical alignment: top, center, bottom (default: top)
##         --at-pointer        Use pointer position (shortcut for --position-mode=pointer)

set -euo pipefail

source ~/.local/lib/dots/easy-options/easyoptions.sh || exit
source ~/.local/lib/dots/logging.sh || exit

SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_NAME

# Paths to configuration files
readonly ORIGINAL_CONFIG_FILE="${config:-$HOME/.config/jgmenu/jgmenurc-config}"
readonly TARGET_CONFIG_FILE="$HOME/.config/jgmenu/jgmenurc"
readonly SMART_COLORS_FILE="$HOME/.cache/dots/smart-colors/colors.sh"

# Position defaults (will be auto-detected if not provided)
POSITION_X="${position_x:-}"
POSITION_Y="${position_y:-}"
POSITION_MODE="${position_mode:-}"
HALIGN="${halign:-left}"
VALIGN="${valign:-top}"

# Check for --at-pointer flag
if [[ ${at_pointer:-no} == yes ]]; then
  POSITION_MODE="pointer"
fi

# Logging adapter to preserve existing call sites.
log() {
  local level="$1"
  shift
  case "$level" in
    ERROR) log_error "$*" ;;
    WARNING|WARN) log_warn "$*" ;;
    INFO) log_info "$*" ;;
    DEBUG) log_debug "$*" ;;
    *) log_info "$*" ;;
  esac
}

# Function to get smart colors with proper fallbacks
get_smart_color() {
  local concept="$1"
  local fallback_xrdb="${2:-background}"

  # Load smart colors from shell variables file if available
  if [[ -f $SMART_COLORS_FILE ]]; then
    # shellcheck source=/dev/null
    source "$SMART_COLORS_FILE"

    # Map concepts to shell variables
    case "$concept" in
      "BACKGROUND")
        echo "${color_black:-$(xrdb -get "background" 2>/dev/null || echo "#1b1f26")}"
        ;;
      "FOREGROUND")
        echo "${color_white:-$(xrdb -get "foreground" 2>/dev/null || echo "#ffffff")}"
        ;;
      "ACCENT")
        echo "${color_accent:-$(xrdb -get "color13" 2>/dev/null || echo "#8fa1b3")}"
        ;;
      "INFO")
        echo "${color_info:-$(xrdb -get "color12" 2>/dev/null || echo "#919ba0")}"
        ;;
      "ERROR")
        echo "${color_error:-$(xrdb -get "color9" 2>/dev/null || echo "#ff6666")}"
        ;;
      "SUCCESS")
        echo "${color_success:-$(xrdb -get "color10" 2>/dev/null || echo "#66ff66")}"
        ;;
      "WARNING")
        echo "${color_warning:-$(xrdb -get "color11" 2>/dev/null || echo "#ffff66")}"
        ;;
      *)
        xrdb -get "$fallback_xrdb" 2>/dev/null || echo "#ffffff"
        ;;
    esac
  else
    # Fallback to xrdb colors if smart colors file doesn't exist
    log "WARNING" "Smart colors file not found, using xrdb fallback"
    xrdb -get "$fallback_xrdb" 2>/dev/null || echo "#ffffff"
  fi
}

# Function to update color placeholders with smart colors
update_color() {
  local color_name="$1"
  local smart_placeholder="$2"
  local opacity_transparency="${3:-100}"

  [[ -z $smart_placeholder ]] && return 0

  # Get the smart color for this placeholder
  local color_value
  color_value=$(get_smart_color "$smart_placeholder")

  # Update the color in the config file, preserving opacity/transparency
  sed -i "s|^$color_name.*= SMART_.*|$color_name = $color_value $opacity_transparency|" "$TARGET_CONFIG_FILE"

  log "INFO" "Updated $color_name with $smart_placeholder ($color_value)"
}

# Validate dependencies
check_dependencies() {
  local missing_deps=()

  if ! command -v jgmenu_run >/dev/null 2>&1; then
    missing_deps+=("jgmenu")
  fi

  if [[ ${#missing_deps[@]} -gt 0 ]]; then
    log "ERROR" "Missing dependencies: ${missing_deps[*]}"
    notify-send -u critical "JGMenu" "Missing dependencies: ${missing_deps[*]}"
    return 1
  fi

  return 0
}

# Auto-detect waybar position and calculate menu position
auto_detect_position() {
  log "INFO" "Auto-detecting menu position from Waybar"

  # Check for required dependencies
  if ! command -v hyprctl >/dev/null 2>&1 || ! command -v jq >/dev/null 2>&1; then
    log "WARNING" "hyprctl or jq not found, falling back to pointer mode"
    POSITION_MODE="${POSITION_MODE:-pointer}"
    return 0
  fi

  # Try to get Waybar info using hyprctl (Hyprland specific)
  local waybar_info
  waybar_info=$(hyprctl clients -j 2>/dev/null | jq -r '.[] | select(.class == "waybar")' 2>/dev/null)

  if [[ -z $waybar_info ]]; then
    log "WARNING" "No Waybar instance found, falling back to pointer mode"
    POSITION_MODE="${POSITION_MODE:-pointer}"
    return 0
  fi

  local bar_x bar_y bar_width bar_height
  bar_x=$(echo "$waybar_info" | jq -r '.at[0]' 2>/dev/null)
  bar_y=$(echo "$waybar_info" | jq -r '.at[1]' 2>/dev/null)
  bar_width=$(echo "$waybar_info" | jq -r '.size[0]' 2>/dev/null)
  bar_height=$(echo "$waybar_info" | jq -r '.size[1]' 2>/dev/null)

  if [[ -z $bar_x || -z $bar_y || -z $bar_width || -z $bar_height ]]; then
    log "WARNING" "Could not parse Waybar geometry, falling back to pointer mode"
    POSITION_MODE="${POSITION_MODE:-pointer}"
    return 0
  fi

  # Determine bar position (top, bottom, left, right) and calculate menu position
  if [[ $bar_y -lt 50 ]]; then
    # Top bar - menu appears below
    POSITION_X="${POSITION_X:-$bar_x}"
    POSITION_Y="${POSITION_Y:-$((bar_y + bar_height + 5))}"
    HALIGN="${HALIGN:-left}"
    VALIGN="top"
    log "INFO" "Detected top bar at (x=$bar_x, y=$bar_y, w=$bar_width, h=$bar_height) → menu at (x=$POSITION_X, y=$POSITION_Y)"
  elif [[ $bar_x -lt 50 ]]; then
    # Left bar - menu appears to the right
    POSITION_X="${POSITION_X:-$((bar_x + bar_width + 5))}"
    POSITION_Y="${POSITION_Y:-$bar_y}"
    HALIGN="left"
    VALIGN="${VALIGN:-top}"
    log "INFO" "Detected left bar at (x=$bar_x, y=$bar_y, w=$bar_width, h=$bar_height) → menu at (x=$POSITION_X, y=$POSITION_Y)"
  else
    # Other positions (right/bottom) - use simple offset
    POSITION_X="${POSITION_X:-$bar_x}"
    POSITION_Y="${POSITION_Y:-$bar_y}"
    log "INFO" "Detected bar at (x=$bar_x, y=$bar_y) → using default positioning"
  fi

  POSITION_MODE="${POSITION_MODE:-fixed}"
  return 0
}

# Apply position configuration to jgmenu config
apply_position_config() {
  log "INFO" "Applying position configuration (mode=$POSITION_MODE)"

  # Set position mode
  if [[ -n $POSITION_MODE ]]; then
    sed -i "s|^position_mode.*=.*|position_mode        = $POSITION_MODE|" "$TARGET_CONFIG_FILE"
    log "INFO" "Set position_mode = $POSITION_MODE"
  fi

  # Set coordinates if in fixed mode
  if [[ $POSITION_MODE == "fixed" ]]; then
    if [[ -n $POSITION_X ]]; then
      sed -i "s|^menu_margin_x.*=.*|menu_margin_x        = $POSITION_X|" "$TARGET_CONFIG_FILE"
      log "INFO" "Set menu_margin_x = $POSITION_X"
    fi

    if [[ -n $POSITION_Y ]]; then
      sed -i "s|^menu_margin_y.*=.*|menu_margin_y        = $POSITION_Y|" "$TARGET_CONFIG_FILE"
      log "INFO" "Set menu_margin_y = $POSITION_Y"
    fi
  fi

  # Set alignment
  if [[ -n $HALIGN ]]; then
    sed -i "s|^menu_halign.*=.*|menu_halign          = $HALIGN|" "$TARGET_CONFIG_FILE"
    log "INFO" "Set menu_halign = $HALIGN"
  fi

  if [[ -n $VALIGN ]]; then
    sed -i "s|^menu_valign.*=.*|menu_valign          = $VALIGN|" "$TARGET_CONFIG_FILE"
    log "INFO" "Set menu_valign = $VALIGN"
  fi
}

# Main execution
main() {
  # Check dependencies
  check_dependencies || exit 1

  # Ensure the original configuration file exists
  if [[ ! -f $ORIGINAL_CONFIG_FILE ]]; then
    log "ERROR" "Configuration file not found: $ORIGINAL_CONFIG_FILE"
    notify-send -u critical "JGMenu" "Configuration file not found"
    exit 1
  fi

  log "INFO" "Copying configuration from $ORIGINAL_CONFIG_FILE to $TARGET_CONFIG_FILE"

  # Copy the original configuration file to the temporary location
  if ! cp "$ORIGINAL_CONFIG_FILE" "$TARGET_CONFIG_FILE"; then
    log "ERROR" "Failed to copy configuration file"
    exit 1
  fi

  # Replace smart color placeholders with actual colors from dots-smart-colors
  log "INFO" "Applying smart colors to jgmenu configuration"
  update_color "color_menu_bg" "BACKGROUND" "98"
  update_color "color_menu_fg" "FOREGROUND" "100"
  update_color "color_norm_bg" "BACKGROUND" "0"
  update_color "color_norm_fg" "FOREGROUND" "100"
  update_color "color_sel_bg" "ACCENT" "60"
  update_color "color_sel_fg" "FOREGROUND" "100"
  update_color "color_sep_fg" "INFO" "40"

  # Auto-detect position if not explicitly set
  if [[ -z $POSITION_MODE || ($POSITION_MODE == "fixed" && (-z $POSITION_X || -z $POSITION_Y)) ]]; then
    auto_detect_position
  fi

  # Apply position configuration
  apply_position_config

  # Set JGMENU_CONFIG to point to the temporary configuration file
  export JGMENU_CONFIG="$TARGET_CONFIG_FILE"

  # Log final configuration
  log "INFO" "Launching jgmenu with:"
  log "INFO" "  Position mode: $POSITION_MODE"
  if [[ $POSITION_MODE == "fixed" ]]; then
    log "INFO" "  Coordinates: x=$POSITION_X, y=$POSITION_Y"
    log "INFO" "  Alignment: halign=$HALIGN, valign=$VALIGN"
  fi

  jgmenu_run
}

main "$@"
