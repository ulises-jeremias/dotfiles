#!/usr/bin/env bash

## Copyright (C) 2019-2025 Ulises Jeremias Cornejo Fandos
## Licensed under MIT.
##
## Check full documentation at: https://github.com/ulises-jeremias/dotfiles/wiki
##
## executable_dots-rofi-rice-selector utility script

set -e

# This script defines the variables: DOTS_CACHE_DIR, RICES_DIR and CURRENT_RICE_FILE
# shellcheck disable=SC1091
source "$HOME/.local/lib/dots/dots-rice-config.sh"

# Rofi theme path
ROFI_THEME="$HOME/.config/rofi/riceselector.rasi"

# Function to check dependencies
check_dependencies() {
  if ! command -v hyprctl >/dev/null 2>&1 && ! command -v xdpyinfo >/dev/null 2>&1; then
    echo "Please install hyprland or xorg-xdpyinfo package to continue"
    notify-send "Missing package" "Please install hyprland or xorg-xdpyinfo package to continue" -u critical
    exit 1
  fi
}

# Function to calculate screen parameters
calculate_screen_parameters() {
  # Detect if running on Wayland (Hyprland) or X11
  if command -v hyprctl >/dev/null 2>&1 && [ "$XDG_SESSION_TYPE" = "wayland" ]; then
    # Wayland/Hyprland method - use focused monitor, fallback to first
    monitor_info=$(hyprctl monitors -j | jq -r '(map(select(.focused == true)) | .[0]) // .[0]')
    monitor_res=$(echo "$monitor_info" | jq -r '.width')
    monitor_height=$(echo "$monitor_info" | jq -r '.height')
    monitor_scale=$(echo "$monitor_info" | jq -r '.scale')
    primary_monitor=$(echo "$monitor_info" | jq -r '.name')

    # Hyprland scale is a float, convert to DPI-like value (96 is base)
    monitor_scale=$(awk "BEGIN {print int(96 * $monitor_scale)}")
  else
    # X11 fallback method
    primary_monitor=$(xrandr | awk '/ connected primary/ {print $1}')
    if [ -z "$primary_monitor" ]; then
      primary_monitor=$(xrandr | awk '/ connected/ {print $1; exit}')
    fi

    monitor_geometry=$(xrandr | grep "^$primary_monitor connected" | grep -oP '\d+x\d+\+\d+\+\d+')
    monitor_res=$(echo "$monitor_geometry" | cut -d '+' -f1 | cut -d 'x' -f1)
    monitor_height=$(echo "$monitor_geometry" | cut -d '+' -f1 | cut -d 'x' -f2)

    monitor_scale=$(xdpyinfo | awk '/resolution/{print $2}' | cut -d 'x' -f1)
  fi

  if [ -z "$monitor_res" ] || [ -z "$monitor_height" ]; then
    echo "Could not determine resolution for monitor $primary_monitor"
    exit 1
  fi

  echo "Monitor: $primary_monitor | Width: $monitor_res | Height: $monitor_height | Scale: $monitor_scale" >&2

  # Validate that monitor_scale is not zero
  if [ -z "$monitor_scale" ] || [ "$monitor_scale" -eq 0 ]; then
    echo "Error: Monitor scale could not be determined or is zero."
    exit 1
  fi

  # Set minimum and proportional values for element size
  element_size_min=500
  element_size_factor=0.5 # 5% of the screen width adjusted by scale
  element_size=$(awk "BEGIN {size=($monitor_res * $element_size_factor / $monitor_scale); if (size < $element_size_min) size=$element_size_min; print int(size)}")

  # Adjust the mainbox height based on screen height
  mainbox_height_factor=0.60 # 60% of the monitor height
  mainbox_height=$(awk "BEGIN {print int($monitor_height * $mainbox_height_factor)}")

  # Calculate vertical padding for top and bottom
  total_vertical_space=$(awk "BEGIN {print $monitor_height - $mainbox_height}")
  padding_top_factor=0.6    # 60% of the total vertical space goes to top padding
  padding_bottom_factor=0.5 # 50% of the total vertical space goes to bottom padding

  padding_top=$(awk "BEGIN {padding = $total_vertical_space * $padding_top_factor; if (padding < 0) padding = 0; print int(padding)}")
  padding_bottom=$(awk "BEGIN {padding = $total_vertical_space * $padding_bottom_factor; if (padding < 0) padding = 0; print int(padding)}")

  # Generate dynamic styles for Rofi with separate top and bottom padding
  rofi_override="element-icon{size:${element_size}px;} window{padding:${padding_top}px 0px ${padding_bottom}px 0px;}"
}

# Function to get rice category based on style
get_rice_category() {
  local rice_name="$1"
  local config_file="${RICES_DIR}/${rice_name}/config.sh"
  local category="Other"

  if [[ -f $config_file ]]; then
    local style
    style=$(grep -E "^RICE_STYLE=" "$config_file" 2>/dev/null | cut -d'"' -f2 | tr '[:upper:]' '[:lower:]')

    case "$style" in
      *cyberpunk* | *neon* | *synthwave* | *futuristic*)
        category="ðŸŒƒ Cyberpunk & Neon"
        ;;
      *cozy* | *kawaii* | *pastel* | *soft*)
        category="ðŸŒ¸ Cozy & Cute"
        ;;
      *vaporwave* | *retro* | *80s* | *90s*)
        category="ðŸŒ´ Retro & Vaporwave"
        ;;
      *nature* | *landscape* | *fresh*)
        category="ðŸŒ¿ Nature & Fresh"
        ;;
      *gruvbox* | *warm* | *anime*)
        category="ðŸŽ¨ Warm & Artistic"
        ;;
      *minimal* | *clean* | *productive*)
        category="ðŸ’¼ Minimal & Productive"
        ;;
      *space* | *cosmic* | *dark*)
        category="ðŸŒŒ Dark & Cosmic"
        ;;
      *)
        category="âœ¨ Other"
        ;;
    esac
  fi

  echo "$category"
}

# Function to list available rices with categories
list_rices() {
  options=()
  categories=()
  index=0
  selected_index=0
  current_rice=""

  if [[ -f $CURRENT_RICE_FILE ]]; then
    current_rice=$(<"$CURRENT_RICE_FILE")
  fi

  # First pass: collect all rices and their categories
  declare -A rice_by_category
  for rice_dir in "${RICES_DIR}"/*/; do
    rice_name=$(basename "$rice_dir")
    # Skip directories that don't have config.sh
    [[ -f "${rice_dir}/config.sh" ]] || continue

    category=$(get_rice_category "$rice_name")
    rice_by_category["$category"]+="$rice_name "
  done

  # Sort categories in preferred order
  local preferred_order=(
    "ðŸŒƒ Cyberpunk & Neon"
    "ðŸŒ´ Retro & Vaporwave"
    "ðŸŒ¸ Cozy & Cute"
    "ðŸŽ¨ Warm & Artistic"
    "ðŸŒ¿ Nature & Fresh"
    "ðŸŒŒ Dark & Cosmic"
    "ðŸ’¼ Minimal & Productive"
    "âœ¨ Other"
  )

  # Build options array in category order
  for category in "${preferred_order[@]}"; do
    if [[ -n ${rice_by_category[$category]:-} ]]; then
      for rice_name in ${rice_by_category[$category]}; do
        options+=("$rice_name")
        categories+=("$category")

        if [[ $current_rice == "$rice_name" ]]; then
          selected_index=$index
        fi

        index=$((index + 1))
      done
    fi
  done

  if [ ${#options[@]} -eq 0 ]; then
    echo "No rices found in $RICES_DIR"
    exit 1
  fi
}

# Function to show rofi menu and select rice with categories
select_rice() {
  local last_category=""
  local menu_items=""
  local idx=0

  for rice_name in "${options[@]}"; do
    local category="${categories[$idx]}"
    local display_name="$rice_name"

    # Add category prefix for display (compact format)
    # The category is embedded in the display name for visual grouping
    if [[ $category != "$last_category" ]]; then
      # New category - add visual separator
      display_name="$(echo "$category" | cut -d' ' -f1) $rice_name"
      last_category="$category"
    else
      # Same category - indent for grouping effect
      display_name="   $rice_name"
    fi

    menu_items+="${display_name}\x00icon\x1f${RICES_DIR}/${rice_name}/preview.png\x1fmeta\x1f${rice_name} ${category}\n"
    idx=$((idx + 1))
  done

  selected=$(echo -en "$menu_items" | rofi -dmenu -theme "$ROFI_THEME" -theme-str "$rofi_override" -selected-row "$selected_index" -p "Select Rice")

  [[ -n $selected ]] || exit 1

  # Extract actual rice name (remove category emoji and spaces)
  selected=$(echo "$selected" | sed 's/^[^a-zA-Z]*//' | xargs)

  # Verify the selected rice exists
  if [[ ! -d "${RICES_DIR}/${selected}" ]]; then
    # Try to find the rice by partial match
    for rice in "${options[@]}"; do
      if [[ $selected == *"$rice"* ]] || [[ $rice == *"$selected"* ]]; then
        selected="$rice"
        break
      fi
    done
  fi

  echo "$selected" >"$CURRENT_RICE_FILE"
}

# Function to list and select a background image
select_background_image() {
  local backgrounds_dir="${RICES_DIR}/${selected}/backgrounds"
  [[ -d $backgrounds_dir ]] || {
    echo "No backgrounds directory found for $selected"
    exit 1
  }

  local images=()
  for image in "$backgrounds_dir"/*; do
    images+=("$(basename "$image")")
  done

  selected_image=$(printf "%s\n" "${images[@]}" | while read -r A; do echo -en "$A\x00icon\x1f$backgrounds_dir/$A\n"; done | rofi -dmenu -theme "$ROFI_THEME" -theme-str "$rofi_override")
  [[ -n $selected_image ]] || exit 1
}

# Function to apply the selected rice with the chosen background
apply_rice() {
  if [[ -x "${RICES_DIR}"/"$selected"/apply.sh ]]; then
    BACKGROUND_IMAGE="$selected_image" "${RICES_DIR}"/"$selected"/apply.sh
    exit 0
  else
    echo "Apply script not found or not executable for $selected"
    exit 1
  fi
}

# Main script execution
main() {
  check_dependencies
  calculate_screen_parameters
  list_rices
  select_rice
  select_background_image
  apply_rice
}

main
